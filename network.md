# 计算机网络

## 网络分层模型

网络分层：

- 相互独立：各层之间不需要关心其他层如何实现，只需要调用相关功能(接口调用)
- 灵活性：各层独立，改变一层的内部实现不会影响其他层的功能(高内聚，低耦合)
- 解决问题：分层便于定位问题的所在，且只需要修改出现问题的层

### OSI 七层模型

- 应用层：为用户提供服务
- 表示层：数据处理(编解码，加解密，加解压)
- 会话层：管理应用程序间的会话
- 传输层：为两台主机通信提供通用的数据传输服务
- 网络层：路由与寻址
- 链路层：帧编码和误差纠正控制
- 物理层：传输比特流

![osi七层模型2](https://oss.javaguide.cn/github/javaguide/osi七层模型2.png)

七层模型的理论完备，实现复杂且不实用(有些功能在多个层中重复出现)



### TCP/IP 四层模型

- 应用层：为用户提供服务
- 传输层：管理两台主机之间的通信
- 网络层：帧编码与误差控制
- 物理链路层：传输比特流

![TCP/IP 四层模型](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png)

#### 应用层

应用层用于**为两台终端的应用程序提供通信服务**，定义了**交互的信息格式(报文)**，再通过传输层进行传输

协议：

- HTTP：超文本传输协议，基于 TCP，用于传输超文本和多媒体内容

  - 客户端发起 HTTP Request，服务端响应 HTTP Response
  - HTTP 1.1 协议默认 Keep-Alive，即建立一次连接后可以重复使用，之后的请求无需再次建立
  - HTTP 协议是无状态的，故需要使用 Cookie/Token 等手段记录访问的客户状态(登录、购物车)

- Websocket：全双工通信协议，基于 TCP，客户端与服务器可以同时发送和接收数据，用于弥补 HTTP 协议无法建立持久连接的不足

  - Websocket 只需要一次握手就可以建立连接

    ![](![Websocket 示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b07779d35f4d33afa13e23e0baeba2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

    1. 客户端向服务器发送升级为 Websocket 连接的请求
    2. 若服务器支持 Websocket，则返回带有相关头的响应
    3. 客户端与服务器可以通过帧通信，数据被分为若干个数据帧发送，接收方再将其重组
    4. 连接建立后通过心跳机制确保通信双方都存活，保证连接的稳定性和活跃性
    5. 双方都可以发送一个结束帧表示结束此次连接，收到结束帧的一方也会返回关闭帧，然后关闭 TCP 连接

  - Websocket 实现实时消息推送：

    - 后端注册为 Websocket 服务器
    - 前端连接后持续监听事件

  - Websocket vs HTTP：

    - 双向 vs 单向
    - ws:// wss:// vs http:// https://
    - Websocket 支持扩展，用户可以扩展协议，实现部分自定义的子协议(压缩、加密)
    - WebSocket 通信数据格式比价轻量，用于协议控制的数据包头部较小；HTTP 通信每次都要携带完整的头部

  - Websocket vs SSE(Server Send Event)：主要出于单/双向、传输内容来决定选择

    - SSE 基于 HTTP 协议，无需额外引入；Websocket 需要单独的服务器处理协议
    - 单向 vs 双向
    - SSE 实现简单，开发成本低；Websocket 传输数据需要二次解析
    - SSE 默认支持断线重连；Websocket 需要扩展
    - SSE 只能传输文本数据，二进制数据需要编码后传输；Websocket 默认支持二进制数据传输

- SMTP：简单邮件发送协议，基于 TCP，用于向邮件服务器发送邮件，且只负责发送而不能接受

  1. 通过 SMTP 协议将写好的邮件交给发送方对应的 SMTP 服务器
  2. 发送方服务器通过域名转发给对应的接收方 SMTP 服务器
  3. 接收方服务器判断目标地址是否有效
  4. 接收方服务器通知接收邮件

- POP3/IMAP：邮件接收协议，基于 TCP

- FTP：文件传输协议，基于 TCP，可以屏蔽操作系统与文件存储方式，在两台终端之间传输文件，SFTP 是 FTP 的安全版本，会对传输过程对数据加密

  - FTP 在两台终端建立两条 TCP 连接，一条用于传送控制信息，一条用于数据传送

- Telnet：远程登录协议，基于 TCP，用于通过一个终端登录到其他服务器，由于登录过程的所有数据(账号密码)都是明文传输，故已被更安全的 SSH 淘汰

- SSH：安全网络传输协议，基于 TCP，通过加密和认证机制实现安全的访问和文件传输等业务

- RTP：实时传输协议，基于 UDP，也支持 TCP，提供 P2P 实时传输数据的功能，但不包含资源预留存，不保证实时传输质量

- DNS：域名管理系统，基于 UDP，用于解决域名与 IP 的映射问题

#### 传输层

传输层负责为两台终端的进程间提供通用的通信协议

- TCP：面向连接、可靠
- UDP：无连接、不可靠、简单高效

#### 网络层

网络层负责两台终端之间的通信，将传输层的报文进行封装成分组和包，再通过路由转发到对应的终端

- IP：定义数据包格式、对数据包进行路由和寻址，以便能够正确地传播到目标地址
- ARP：Address Resolution Protocol，地址解析协议，解决网络层与链路层的差异(网络层使用逻辑地址 IP，链路层使用物理地址 MAC)
- ICMP：Internet Control Message Protocol，网络控制报文协议，用于传输网络状态和错误消息的协议
- NAT：Network Address Table，网络地址转换协议，用于转换内网与外网的地址，如在 LAN 内各主机使用内网地址，在 WAN 中需要统一的 IP 地址标识 LAN 在 Internet 上的位置
- OSPF：Open Shortest Path First，开放式最短路径优先，广泛使用的动态路由协议，考虑了链路带宽、延迟等
- RIP：动态路由协议，只考虑路由路径的跳数
- BGP：动态路由协议，用于在路由选择域之间交换网络层可达性信息

#### 网络接口层

包含链路层与物理层

- 链路层：将 IP 数据包封装成帧，在两个相邻节点间的链路上传送帧，每一帧包括数据和控制信息(同步信息，地址信息，差错控制)
- 物理层：实现相邻计算机节点之间比特流的透明传送

## 访问网页流程

1. 浏览器输入网站 URL
2. 通过 DNS 将域名解析为 IP 地址
3. 通过 IP + 端口向服务器请求建立 TCP 连接
4. 向服务器发送 HTTP 请求
5. 服务器将页面的 HTML 代码与相关资源封装到 HTTP 响应中返回
6. 浏览器解析 HTML
7. 关闭时客户端发送 HTTP 关闭请求

### URL

Uniform Resource Link，统一资源定位器，类似于文件路径，通过 URL 可以访问对应的网络资源，一个 URL 对应一个网络资源，一个网络资源可以通过重定向由多个 URL 指向

- 协议：HTTP/HTTPS/FTP
- 域名：IP 地址的别名，便于记忆
- 端口：指定的访问端口
- 资源路径：
- 参数
- 锚点

#### URL vs URI

- URI：统一资源标志符，可以唯一标识一个资源

- URL：统一资源定位符，提供资源的路径，是一种具体的 URI，即 URL 标识资源的同时提供了访问路径

### DNS

基于 UDP 的应用层协议，用于解决 IP 与域名的映射关系，host 表中存在对应关系时不需要通过 DNS 解析

DNS 服务器自下而上分为四个层级：

- 根服务器：提供顶域服务器的 IP 地址
- 顶域服务器：顶域指域名的后缀(com/edu/org/cn)，提供权威服务器的 IP 地址
- 权威服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将主机名映射为 IP 地址
- 本地服务器：由 ISP 提供的 DNS 服务器，主机发出 DNS 请求时首先由本地服务器代理转发到 DNS 层次结构中，严格上不属于 DNS 层级结构

#### 工作流程

迭代式：

![](https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process.png)

1. 主机 --(DNS 请求)--> 本地 DNS 服务器
2. 本地服务器检查缓存，若存在则之间返回，否则请求根服务器
3. 根服务器由顶域将对应的顶域服务器 IP 地址返回给本地服务器
4. 本地服务器请求返回的顶域服务器
5. 顶域服务器由域名前缀将对应的权威服务器 IP 地址返回给本地服务器
6. 本地服务器请求返回的权威服务器
7. 权威服务器将备案过的域名 IP 地址返回
8. 本地服务器将获取的 IP 地址返回给主机

递归式：

![](![](https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process2.png))

与迭代式的不同之处在于请求会 DNS 体系内直到确认对应的 IP 地址是否存在后才逐级返回至本地服务器

#### DNS 劫持

DNS 劫持是一种网络攻击，通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，导致用户无法访问正常的网站或被引导到恶意网站

DNS 劫持方法：

- 利用 DNS 服务器进行 DDoS 攻击：攻击者得到被攻击者的 IP 地址，对其 DNS 服务器发送大量解析请求，这些请求最终会返回给被攻击者，导致被攻击者的网络被拖垮至中断。由于攻击者没有直接与被攻击者通讯，故难以追查原始的攻击者
- DNS 缓存感染：攻击者使用 DNS 请求将数据放入一个具有漏洞的 DNS 服务器的缓存中，这些缓存信息会在用户进行 DNS 访问时返回，从而把用户对正常域名的访问引导至恶意网站
- DNS 信息劫持：攻击者通过监听客户端和 DNS 服务器的对话，可以猜测服务器响应给客户端的 DNS 查询 Id(DNS 通过 DNS 报文的 16 位 Id 号获取请求源位置)，攻击者在 DNS 服务器之前将虚假的响应交给用户，从而引导用户访问恶意网站
- DNS 重定向：攻击者将 DNS 名称查询重定向到恶意 DNS 服务器上，被劫持域名的解析就完全由攻击者控制

预防：

- 绕过运营商的 DNS，向具备 DNS 解析功能的 HTTP WEB 服务器发起查询(直接向 DNS 发送更加安全的 HTTP 请求)
  - 核心业务向 HTTP DNS 发送请求
  - 非核心业务先尝试 LocalDNS，发生异常时走 HTTP DNS

## HTTP

- 基于 TCP 的应用层协议
- 用于传输超文本与多媒体资源
- 默认为 80 端口
- HTTP 1.1 默认开启 Keep-Alive，避免每次请求都要重新建立连接
- 无状态的协议，不维护任何客户端过去所发请求的信息(维护状态的开销大，且双方因为故障导致状态不一致时代价更高)，需要额外的 Cookie/Token 来记录客户端状态(登录、购物车)
- 扩展性强、速度快、跨平台

### HTTP 状态码

- 1xx：信息性状态码
- 2xx：成功状态码
  - 200：请求成功处理
  - 201：请求成功处理，且在服务器上创建了新的资源
  - 202：服务器收到请求，但未处理
  - 204：请求成功处理，但未返回任何内容
- 3xx：重定向状态码
  - 301：资源被永久重定向(网站的网址更换)
  - 302：资源被临时重定向
- 4xx：客户端错误状态码
  - 400：发送的请求存在问题(参数不合法、请求方法错误)
  - 401：请求未认证
  - 403：服务器拒绝请求，一般针对非法请求
  - 404：请求的资源不存在
  - 409：请求的资源与服务器当前状态冲突，无法处理请求
- 5xx：服务端错误状态码
  - 500：服务器出 bug，请求未正常处理
  - 502：网关将请求转发到服务器，服务器返回的式错误的响应
  - 504：请求超时

### HTTPS

- 基于 SSL/TLS 协议，SSL/TLS 基于 TCP
- 双方传输的数据采用对称加密，对称加密所用的密钥由服务器的证书进行非对称加密
- 安全性高、开销更大

#### SSL vs TLS 

两者没有太大区别，TLS 是基于 SSL 的升级版(SSL 3.0)

#### 非对称加密

- 发送方使用接收方的公钥对数据进行加密
- 接收方使用自己的私钥对数据进行解密

公钥只能加密，无法解密，只有私钥才能解密，公私钥的生成依赖单向陷门函数(只能由 a -> b，无法由 b -> a，但存在 x 能够得到 b -> a )

非对称加密的算法开销大，效率低

#### 对称加密

发送方与接收方使用相同的密钥对传输数据进行加解密

传输数据的保密性完全依赖于密钥的保密性，因此常使用非对称加密传输对称加密所用的密钥

#### 公钥传输问题

由于：

- 任何人可以捕获通信包
- 通信包的保密性由发送者设计
- 公钥加密算法是公开的

则存在客户 C，服务器 S，攻击者 A：

- C 向 S 发送获取公钥的请求
- A 拦截请求并使用自己的公钥 Pub_A 伪造响应
- C 得到 Pub_A 并以此加密数据发送给 S
- A 拦截发送的数据并用自己的 Pri_A 解密
  - 由于加密使用的是 Pub_A，故攻击者能够解密出客户端想要发送的数据，造成数据的泄漏

为此产生了权威的第三方证书颁发机构(CA)，HTTPS 请求会先验证公钥是否有 CA 认证，若有则表示此公钥为目标服务器的公钥，否则不能保证该公钥的合法性

CA 利用数字签名(散列 + 加密的组合技术)防止证书被伪造，客户端会通过 CA 的公钥解密服务器返回的证书，得到 CA 生成的摘要，对比客户端自己对获取到的服务器公钥进行散列得到的摘要，由此确定公钥的合法性

证书 = 服务器端的消息 + CA 私钥加密过的 CA 生成的散列

即：

- S 信任 CA，CA 已知 Pub_S，向 S 颁发证书并附上 CA 私钥对摘要的数字签名
- S 将证书返回给 C
- C 信任 CA 且得到 CA 公钥，使用 Pub_CA 对 S 证书上的签名解密，同时对消息进行散列处理得到摘要，对比解密得到的摘要与客户端对消息散列得到的摘要
- C 验证 S 证书真实则信任 S 的公钥

#### HTTP vs HTTPS

- 端口：HTTP 默认为 80；HTTPS 默认为 443
- 域名：http vs https
- 性能：HTTP 性能更好；HTTPS 为了保证安全性，存在算法开销与证书/密钥的传输
- 搜索引擎：搜索引擎倾向于返回 HTTPS 的结果

### HTTP 1.0 vs HTTP 1.1

- 状态码：HTTP 1.0 只有 16 种，HTTP 1.1 新增了 24 种
- 缓存处理：
  - HTTP 1.0：使用 Expired 标签标志一个响应体，在标志时间内的请求都会获得缓存，由 Last-Modified 标记被请求资源的最后一次修改。在请求头中使用 If-Modified-Since 表示在该时间后资源是否被修改，若未修改则返回 304 告知客户端缓存仍可用，否则返回 200 并附带更新后的资源
  - HTTP 1.1：在 1.0 的基础上引入了 Cache-Control 请求头，对缓存增加了更多细致的特性
- 连接方式：协议上的连接，真正实现需要客户端与服务器都支持长连接
  - HTTP 1.0：默认使用短连接，每次请求都需要新建连接，产生大量的握手与挥手报文占用带宽，可以使用 Connection: Keep-alive 开启长连接
  - HTTP 1.1：默认为长连接，建立连接后一直存在，可以使用 Connection: close 表示此为短连接
- Host 头处理：DNS 支持多个域名绑定到同一 IP
  - HTTP 1.0 的请求报文不会加入主机名，服务器端无法理解客户端想请求的真正网址
  - HTTP 1.1 中加入了 Host 字段，由此确定客户端想访问的网址
- 带宽优化：
  - HTTP 1.1 通过 Range 请求头实现范围请求，服务端可以只返回一部分数据，也可以忽略 Range，范围请求的返回状态码为 206，表示该响应不是一个完整的数据响应。Content-Range 头标识指示出该数据块的偏移量和数据库长度
  - HTTP 1.1 中引入 100 状态码，表示服务器不愿意响应某些较大的文件请求，进一步向客户端确认请求的必要性，若客户端确认需要则会正常返回
  - HTTP 1.1 提供了比 HTTP 1.0 更细致的压缩细节选择

### HTTP 1.1 vs HTTP 2.0

- 多路复用：HTTP 2.0 在同一连接上可以同时传输多个请求和响应，互不干扰，在处理多个请求时效率更高
- 二进制帧：HTTP 2.0 使用比 HTTP 1.1 的文本格式更高效的二进制帧进行数据传输，减少传输的数据量和带宽消耗
- 头部压缩：HTTP 2.0 支持 Header 压缩，HTTP 1.1 只能对 Body 压缩
- 服务器推送：HTTP 2.0 支持服务器在响应客户端时主动将相关资源一并返回，减少客户端请求次数；HTTP 1.1 只能由客户端逐个发起请求

### HTTP 2.0 vs HTTP 3.0

- 传输协议：HTTP 3.0 新增了 QUIC(Quick UDP Internet Connection) 协议实现可靠传输，提供与 SSL/TLS 相当的安全性，具有较低的连接和传输延迟
- 连接建立：HTTP 3.0 基于 QUIC，连接建立仅需要 0-RTT 或 1-RTT(TLS 1.3 支持 0-1 个 RTT 握手)，即 QUIC 在最佳情况下不需要任何额外往返时间即可建立新连接
- 队头阻塞：HTTP 2.0 在多路复用时，一旦发生丢包就会阻塞所有 HTTP 请求；HTTP 3.0 基于多路复用 + 轮询，在一个连接建立多个不同且独立的数据流
- 错误恢复：HTTP 3.0 在出现丢包、延迟等网络问题时能更快地进行恢复与重传；HTTP 2.0 基于 TCP 的错误恢复机制
- 安全性：HTTP 3.0 改为基于 QUIC 内置的加密和身份验证机制，提供更强的安全性

### HTTP 维护用户状态

利用 Session 机制，通过服务端为用户创建特定的 Session 来标识用户并跟踪

服务器保存 Session：

- 内存 + 数据库(redis)

#### Cookie vs Session

- Session 用于通过服务端记录用户的状态，通过 Session 标识与跟踪用户，Session保存在服务器，安全性更高
- Cookie 数据保存在客户端(浏览器)，不需要占用服务器资源