# 操作系统

管理计算机硬件与软件资源的程序，屏蔽了硬件层的复杂性，由内核负责内存、硬件设备、文件系统、应用程序的管理，成为连接应用程序与硬件的桥梁

## 功能

- 线程与进程：进程的创建、撤销、阻塞、唤醒，进程间通信
- 存储：内存管理，外部存储(磁盘)管理
- 文件：文件的读、写、删除
- 设备：I/O 设备、外部存储设备的管理
- 网络：管理计算机网络的使用，管理计算机网络的配置、连接、通信、安全等，提供高效可靠的网络服务
- 安全：用户的身份认证、访问控制、文件加密等，防止非法用户对系统资源的访问和操作

## 用户态与内核态

- 用户态：处于用户态的线程**能够访问应用程序的数据**，但要读写磁盘、网络通信时**需要发起系统调用**，等待操作系统由用户态转为内核态完成相关请求后返回结果并切换回用户态
- 内核态：处于内核态的线程能够访问操作系统的所有系统资源，**不受任何限制**，内核态拥有更高的权限，能够执行更加底层、敏感的操作，但也需要**更高的开销**

### 区分用户态与内核态的好处

- 安全性：避免了应用程序直接操作系统资源而造成的对操作系统的破坏(内存分配，I/O 处理，时钟设置)
- 性能：只有一个内核态时，所有的进程都共享系统资源(内存、CPU)导致竞争激烈，降低效率，且所有进程的权限相同使得进程能互相直接访问，降低安全性

### 用户态与内核态的切换

- 系统调用：应用程序需要执行特权指令(磁盘读写、网络通信)，故主动向操作系统发起系统调用，操作系统由此切换至内核态处理。系统调用的核心机制是利用操作系统特别开放的中断操作
- 中断：外部设备(I/O 设备)向 CPU 发出的中断信号，CPU 收到后会停止下一条指令的执行，转而执行与中断请求相关的应用程序的指令，若之前执行的是应用程序的指令，那会自然地从用户态切换至内核态进行处理。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作
- 异常：操作系统运行时发生用户态无法处理的异常，需要切换至内核态进行处理(缺页异常)

#### 系统调用

应用程序需要完成与系统资源相关的操作时(内存管理、设备管理、进程管理等)，会调用操作系统提供的指令，请求操作系统代为执行

- 设备管理：外部设备的请求与释放
- 内存管理：内存分配、回收
- 进程管理：进程的创建、撤销、阻塞、唤醒、通信
- 文件管理：文件的读写、创建、删除

即通过系统调用，应用程序获得了有限的操作系统资源的能力

流程：

1. 用户态的应用程序发起系统调用，由于系统调用中存在特权指令，权限不够的应用程序发起中断(Trap)
2. CPU 执行程序被中断，跳转至中断处理程序，切换至内核态执行系统调用指令
3. 内核态完成请求后主动触发 Trap，切换回用户态继续执行应用程序工作

![系统调用的过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call-procedure.png)

## 进程与线程

- 进程：进程即一个程序实例，包含了程序执行所需的资源，多个进程之间的资源不共享
- 线程：线程是系统调度的最小单位，一个进程可以包含多个线程，多个线程之间共享同一个进程的资源(堆、方法区)，线程自身也有私有的资源(程序计数器、虚拟机栈、本地方法栈)，线程之间的通信与调度开销远小于进程

### 进程 vs 线程

- 资源共享：进程的资源是相互独立的；线程之间共享同一个进程的资源，线程也有自身私有的资源
- 开销：进程的创建、回收、调度的开销远大于线程，一个进程能创建多个线程
- 安全性：进程的安全性优于线程(资源独立)

### 线程的必要性

- 性能：
  - 线程更加轻量，一个进程内部能创建多个线程
  - 线程之间共享进程资源，通信不需要经过内核态
  - 切换线程的开销远小于切换进程
- 并发：一个线程只能做一件事，多个线程可以利用多核 CPU 并发处理多件事

### 线程同步方式

- 互斥锁：只有一个线程能够持有锁，阻塞其他所有线程，保证同一时间只有一个线程能够操作资源
  - synchronized
  - Lock
- 读写锁：由读、写操作区分读锁与写锁，读锁可以由多个线程持有，写锁只能由一个线程持有
  - ReentrantReadWriteLock
- 信号量：由信号量来确定同时能有多少线程操作资源
  - 生产者-消费者模型
- 屏障：类似同步点，线程执行至屏障处会阻塞，直到所有线程都到达屏障后才能继续执行
  - CountDownLatch
  - CyclicBarrier
- 事件：使用 notify/wait 来控制线程访问，便于实现多线程优先级的比较操作
  - Condition

### PCB

Process Control Block，进程控制块，操作系统创建进程时会分配 pid 与对应的 PCB，用于获取/管理进程信息

- 进程描述信息：进程名、标识符
- 进程运行信息：进程阻塞原因、进程状态(READY/RUNNING/BLOCK/WAIT/CANCEL)、进程优先级
- 进程占用的资源：进程打开的文件、需求的 CPU 时间、内存空间、I/O 资源

### 进程状态

- NEW：进程刚被创建出来
- READY：进程准备好运行所需的资源，等待 CPU 分配
- RUNNING：进程被 CPU 执行
- WAITING：进程等待运行所需的资源(锁/CPU)而阻塞
- TERMINATED：进程结束/中断退出运行

![进程状态图转换图](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/state-transition-of-process.png)

### 进程通信

进程之间是独立的，要实现进程间通信必须依赖系统的内核作为中间人处理，即在内核中开辟缓冲区，两个进程通过对其读写实现通信

![](https://upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)

#### 匿名管道

在具有亲缘关系的进程(父子、兄弟)之间，通过内核缓冲区的读写进行通信

![](https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip|imageView2/2/w/228/format/webp)

- 单向通信：数据只能向一个方向流动，双方读写必须建立两个管道
- 亲缘关系：只能在父子、兄弟进程间使用
- 独立的文件系统：管道本质是缓冲区，对进程而言就是在文件中进行读写，管道不是普通的文件，不属于某种文件系统，而是单独构成一种文件系统，只存在于内存中
- FIFO：写入的数据在管道尾部，读取的数据在管道头部，不能随意更改读写的位置

管道本质上是一个 FIFO 循环队列的缓冲区，使用类似生产者-消费者模型来处理缓冲区已满/已空的情况(已满时阻塞生产者，已空时阻塞消费者，在处理后唤醒)

阻塞问题：无名管道无需显式打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。

- 当前进程向匿名管道的一端写数据，必须确定另一端有某一进程
- 若写入匿名管道的数据超过其最大值，写操作将阻塞
- 若管道中没有数据，读操作将阻塞
- 若管道发现另一端断开，将自动退出

缺点：

- 单向
- 亲缘
- 有限：管道存在于内存中，创建时为缓冲区分配一个页面大小
- 匿名
- 格式：管道传输的是无格式字节流，需要双方事先约定好数据格式(一个消息/命令/记录包含多少字节)

#### 有名管道

通过以文件形式将缓冲区放在文件系统中，得到一条访问路径，即使没有亲缘关系的进程也能通过路径来对缓冲区进行读写

有名管道也是严格遵守 FIFO

阻塞问题：有名管道在打开时需要确定对方的存在，否则将阻塞

- 以读方式打开管道，在此之前必须一个进程以写方式打开管道，否则阻塞
- 以读写方式打开有名管道，即以当前线程读，当前线程写，不会阻塞

#### 信号(Signal)

信号是 Linux 系统中用于进程间通信的一种机制，信号的发送方不需要关注接受方的状态(任何时候都可以发送)

若接收方未处于执行状态(READY/WAITING)或阻塞信号的接收，则由内核保存信号，直到接收方开始执行时再传递；若接收方已退出(TERMINATED)，则内核直接丢弃信号

信号是**软件层次上对中断机制的模拟**，是一种**异步通信**方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发送了哪些系统事件，信号的产生可以是硬件的输入(ctrl + c，硬件异常，无效的存储访问)，或软件指令(kill)

信号的生命周期：

1. 发送方生成信号，设置接收方信息(pid)，传递给操作系统
2. 操作系统根据接收方状态选择性地发送
   - 阻塞：内核保存信号，等待接收方解除阻塞
   - 执行：内核传递信号
   - 退出：接收方进程已退出，则内核直接丢弃信号
3. 接收方收到内核传递的信号，中断当前执行的程序，保存上下文(寄存器数据、程序执行位置、CPU 状态)，根据信号中设置的预处理方式执行中断服务程序，完成后恢复到中断的位置

#### 消息队列

消息队列是存放在内核中的消息链表，每个消息队列都有一个消息队列标识符

- 存储：消息队列存放在内核中，只有内核重启、手动删除才会被删除
- 访问：消息队列遵循 FIFO 原则，但也能实现随机访问
- 使用：消息队列不需要读写双方的注册，即不同于管道，消息队列的写操作不需要另一个进程在队列等待消息到达
- 并发：消息队列支持多个进程读写
- 对比：
  - 管道：传输的信息具有特定的格式(管道为无格式字节流)，不受缓冲区大小限制，读写双方独立进行
  - 信号：能够传输更多信息量

#### 共享内存

进程间直接读写同一块内存空间，即内核中专门开辟一块内存区，进程将该内存地址映射到自己的私有地址空间，之后通过直接修改内存数据进行通信，而不需要进行数据拷贝，是**效率最高的通信方式**，需要额外的同步方式确保同步安全(信号量)

![](https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)

#### 信号量

信号量是一个计数器，用于多线程访问共享数据时的进程间同步

为了获取共享资源，进程需要：

1. 创建信号量：调用者指定初始值
2. 等待信号量：测试信号量的值，若小于 0 则阻塞(P 操作)
3. 挂出信号量：将信号量的值加 1(V 操作)

P/V 操作都是原子操作，故信号量通常在内核实现

![两个进程使用一个二值信号量](https://upload-images.jianshu.io/upload_images/1281379-376528c40d03717e.png?imageMogr2/auto-orient/strip|imageView2/2/w/635/format/webp)

![两个进程使用一个 Posix 有名二值信号量](https://upload-images.jianshu.io/upload_images/1281379-a72c8fbe22340031.png?imageMogr2/auto-orient/strip|imageView2/2/w/613/format/webp)

![一个进程两个线程共享基于内存的信号量](https://upload-images.jianshu.io/upload_images/1281379-a1b276fae9db985d.png?imageMogr2/auto-orient/strip|imageView2/2/w/284/format/webp)

##### 信号量 vs 互斥量

- 用途：
  - 互斥量用于线程的互斥，保证同一时间只有一个线程能够操作资源，具有唯一性与排他性，但无法限制访问顺序(无序)
  - 信号量用于线程的同步，在互斥的基础(大多数情况)通过其他机制实现访问者对资源的有序访问

#### 套接字(socket)

socket 是一种通信机制，客户/服务器(进行通信的进程)系统的开发工作既可以在本地单机进行，也可以跨网络进行，即可以让两个计算机进程通过网络连接

![Socket 是应用层和传输层之间的桥梁](https://upload-images.jianshu.io/upload_images/1281379-2db1deb0115ec4f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/319/format/webp)

socket 是 TCP/IP 通信的基本操作单元，不同主机间的进程进行双向通信的端点，通信双方通过 socket 中的相关函数完成通信过程

socket 由 3 个属性确定：域、端口号、协议类型

##### 域

指定 socket 通信中的网络介质：

- AF_INET：Internet 网络，需要服务器的 IP 和端口号指定一台联网机器上的某个特定服务，所以在使用 socket 作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接
- AF_UNIX：UNIX 文件系统，即文件的输入/输出，以文件名为地址

##### 端口号

每个基于 TCP/IP 网络通信的进程都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留 socket 中的输入/输出信息，端口号用于区别主机上的每个进程

每个 socket 通过组合进程 IP 和端口来区别

##### socket 协议类型

Internet 提供 3 种通信机制：

- 流套接字：在域中通过 TCP/IP 连接实现，也是 AF_UNIX 中常用的类型。流套接字提供一个**有序、可靠、双向字节流**的连接，可以确保发送的数据不会丢失、重复、乱序，且有一定的出错重传机制
- 数据包套接字：不需要建立与维护连接，在域中通过 UDP/IP 协议实现。对可发送的数据长度有限制，数据包作为单独的网络消息被传输，可能丢失、重复、乱序，即 **UDP 不是一个可靠的协议，但是效率更高(不需要建立连接)**
- 原始套接字：**允许对较低层次的协议直接访问**(IP、ICMP)，常用于检验新的协议实现，或访问现有服务中配置的新设备，因为原始套接字能够自如地控制 Windows 下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字操作网络层和传输层应用
  - 原始套接字可以读写内核没有处理的 IP 数据包，流套接字只能读取 TCP 协议的数据，数据套接字只能读取 UDP 协议的数据

##### socket 通信的建立

- 服务器：
  1. 服务器应用程序通过系统调用创建一个 socket，它是系统分配给服务器进程的类似文件描述符的资源，不能与其他进程共享
  2. 进程给 socket 命名(系统调用 bind)后开始等待客户连接到该 socket
  3. 系统调用 listen 来创建队列，用于存放来自客户的连接
  4. 服务器通过系统调用 accept 接受客户连接，创建一个与原有的命名 socket 不同的新 socket，该 socket 只用于与这个特定客户通信，而命名 socket(原 socket) 保留下来继续处理来自其他客户的连接
- 客户端：
  1. 客户应用程序首先调用 socket 创建未命名 socket，将服务器的命名 socket 作为地址来调用 connect 与服务器建立连接
  2. 建立连接后可以像使用底层的文件描述符一样用 socket 实现双向数据的通信(通过流进行数据传输)

![socket 通信基本流程](https://upload-images.jianshu.io/upload_images/1281379-2575b81bbab6b67b.png?imageMogr2/auto-orient/strip|imageView2/2/w/437/format/webp)

### 进程的调度算法

- FCFS：先到的请求先服务，直到执行完毕或被阻塞中断
- SJF：短时间任务优先
- RR：绝对公平地为每个任务分配时间片轮询
- MFQ：多级反馈队列调度算法，既能使高优先级的作业得到响应又能使短作业迅速完成
- Priority：为每个任务分配优先级，首先执行具有最高优先级的进程

### 僵尸进程与孤儿进程

父进程通过 fork() 创建子进程，子进程是父进程的副本，有自己的资源与 PCB，父子进程的运行相互独立，且当父进程通过系统调用 exit() 结束生命时，内核会释放父进程的所有资源(内存，文件)，但进程的 PCB 仍然存在，只有父进程调用 wait()/waitpid() 时才会被回收，以便父进程获取子进程状态

- 僵尸进程：子进程已经结束，但父进程没有及时调用 wait() 导致子进程的 PCB 一直存在于系统中，无法被进一步使用
- 孤儿进程：父进程已经结束(意外终止，未及时调用 wait())，子进程仍在运行。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程(进程号为 1)，由 init 进程来回收孤儿进程的资源

## 死锁

死锁即多个线程都需要对方持有的资源才能继续执行，但每个线程都不会主动放弃持有的资源，由此所有线程的执行都被无限期地阻塞

### 产生死锁的必要条件

- 占用并等待：线程不会主动放弃资源
- 非抢占：线程持有的资源不会被夺取
- 循环等待：线程的资源请求链形成环
- 互斥：线程请求的资源不可共享

死锁的产生必然满足上述的所有条件

### 解决死锁的方法

- 预防：采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足
- 避免：系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁发生
- 检测：系统设有专门的机构，检测并定位死锁有关的进程与资源
- 解除：将进程从死锁状态下解脱

#### 预防

破坏死锁的产生条件：

- 互斥：使得资源可以同时访问
- 非抢占：采用剥夺式调度算法，一般仅适用于主存资源和处理器资源的分配，会导致资源利用率下降

能够预防系统发生死锁，但会导致低效的进程运行和资源利用率

##### 静态分配策略

一个进程必须在执行前获取到执行所需的全部资源，即要么占有所有资源，要么全部放弃(破坏占有并等待的条件)

静态分配策略逻辑简单，实现容易，但这种策略严重地降低了资源利用率，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些**几乎不用的资源而使其他需要该资源的进程产生等待**的情况

##### 层次分配策略

所有资源被分成多个层次，一个进程得到某一层的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源(破坏循环等待，因为已经获取到高层资源的进程无法申请低层资源)

#### 避免

运行存在死锁产生的条件，通过合理的资源分配避免死锁

- 安全状态：存在一种资源分配方案，令每个进程在有限时间内都能获取到满足执行的资源

每当在为申请者分配资源前先测试系统状态，若系统资源分配给申请者可能产生死锁，则拒绝分配

##### 银行家算法

当一个进程申请使用资源时，通过先试探分配给该进程资源，然后通过安全性算法判断分配后系统是否处于安全状态，若不安全则试探分配作废，让进程继续等待；若能进入安全状态，则真正分配资源

![](https://img-blog.csdn.net/20180508204335770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDE0Mjcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. P1 申请资源，银行家算法先试探地分配，若空闲资源不够，直接拒绝
2. 判断分配给 P1 后剩余的资源是否能够满足进程队列中的某个进程执行完毕，若没有则为不安全状态，可能出现死锁
   - 已被满足的进程会将持有的资源返回，但 P1 一次申请的资源未必是满足完全执行的

#### 检测

对资源的分配加以限制可以预防/避免死锁发生，但不利于各进程对系统资源的充分共享，解决死锁问题的另一条途径是死锁检测和解除

- 预防/避免 vs 悲观锁：预防/避免方案类似悲观锁，总是假定死锁一定会发生，故分配资源十分谨慎
- 检测/解除 vs 乐观锁：检测/解除方案类似乐观锁，只会在死锁发生后才进行处理

检测对资源的分配不加任何限制，也不采取死锁避免措施，但系统定时运行一个死锁检测程序，判断系统内是否存在死锁，再采取措施去解除

##### 进程-资源分配图

操作系统中的每一时刻的系统状态都可以用进程-资源分配图来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于检测系统是否处于死锁状态

![进程-资源分配图](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/process-resource-allocation-diagram.jpg)

由进程-资源分配图可以看出资源的分配是否存在占有和等待资源的环路

##### 检测步骤

1. 判断进程-资源分配图是否存在环路
2. 进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已发生死锁
3. 进程-资源分配图中有环路，且涉及到的资源类有多个资源
   1. 若能在进程-资源分配图中找到一个既不阻塞又非独立的进程，该进程能够在有限的时间内归还占有的资源，即把边消除，重复此过程，直到有限时间内消除所有边，则不会发生死锁

#### 解除

- 结束所有进程执行，重启操作系统：丢失所有工作，损失大
- 撤销涉及死锁的所有进程，解除死锁后继续执行：丢失进程工作结果
- 逐个撤销涉及死锁的进程，回收资源直至死锁消除
- 抢占资源：从涉及死锁的进程中抢占资源再分配直至死锁解除