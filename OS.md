# 操作系统

管理计算机硬件与软件资源的程序，屏蔽了硬件层的复杂性，由内核负责内存、硬件设备、文件系统、应用程序的管理，成为连接应用程序与硬件的桥梁

## 功能

- 线程与进程：进程的创建、撤销、阻塞、唤醒，进程间通信
- 存储：内存管理，外部存储(磁盘)管理
- 文件：文件的读、写、删除
- 设备：I/O 设备、外部存储设备的管理
- 网络：管理计算机网络的使用，管理计算机网络的配置、连接、通信、安全等，提供高效可靠的网络服务
- 安全：用户的身份认证、访问控制、文件加密等，防止非法用户对系统资源的访问和操作

## 用户态与内核态

- 用户态：处于用户态的线程**能够访问应用程序的数据**，但要读写磁盘、网络通信时**需要发起系统调用**，等待操作系统由用户态转为内核态完成相关请求后返回结果并切换回用户态
- 内核态：处于内核态的线程能够访问操作系统的所有系统资源，**不受任何限制**，内核态拥有更高的权限，能够执行更加底层、敏感的操作，但也需要**更高的开销**

### 区分用户态与内核态的好处

- 安全性：避免了应用程序直接操作系统资源而造成的对操作系统的破坏(内存分配，I/O 处理，时钟设置)
- 性能：只有一个内核态时，所有的进程都共享系统资源(内存、CPU)导致竞争激烈，降低效率，且所有进程的权限相同使得进程能互相直接访问，降低安全性

### 用户态与内核态的切换

- 系统调用：应用程序需要执行特权指令(磁盘读写、网络通信)，故主动向操作系统发起系统调用，操作系统由此切换至内核态处理。系统调用的核心机制是利用操作系统特别开放的中断操作
- 中断：外部设备(I/O 设备)向 CPU 发出的中断信号，CPU 收到后会停止下一条指令的执行，转而执行与中断请求相关的应用程序的指令，若之前执行的是应用程序的指令，那会自然地从用户态切换至内核态进行处理。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作
- 异常：操作系统运行时发生用户态无法处理的异常，需要切换至内核态进行处理(缺页异常)

#### 系统调用

应用程序需要完成与系统资源相关的操作时(内存管理、设备管理、进程管理等)，会调用操作系统提供的指令，请求操作系统代为执行

- 设备管理：外部设备的请求与释放
- 内存管理：内存分配、回收
- 进程管理：进程的创建、撤销、阻塞、唤醒、通信
- 文件管理：文件的读写、创建、删除

即通过系统调用，应用程序获得了有限的操作系统资源的能力

流程：

1. 用户态的应用程序发起系统调用，由于系统调用中存在特权指令，权限不够的应用程序发起中断(Trap)
2. CPU 执行程序被中断，跳转至中断处理程序，切换至内核态执行系统调用指令
3. 内核态完成请求后主动触发 Trap，切换回用户态继续执行应用程序工作

![系统调用的过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call-procedure.png)

## 进程与线程

- 进程：进程即一个程序实例，包含了程序执行所需的资源，多个进程之间的资源不共享
- 线程：线程是系统调度的最小单位，一个进程可以包含多个线程，多个线程之间共享同一个进程的资源(堆、方法区)，线程自身也有私有的资源(程序计数器、虚拟机栈、本地方法栈)，线程之间的通信与调度开销远小于进程

### 进程 vs 线程

- 资源共享：进程的资源是相互独立的；线程之间共享同一个进程的资源，线程也有自身私有的资源
- 开销：进程的创建、回收、调度的开销远大于线程，一个进程能创建多个线程
- 安全性：进程的安全性优于线程(资源独立)

### 线程的必要性

- 性能：
  - 线程更加轻量，一个进程内部能创建多个线程
  - 线程之间共享进程资源，通信不需要经过内核态
  - 切换线程的开销远小于切换进程
- 并发：一个线程只能做一件事，多个线程可以利用多核 CPU 并发处理多件事

### 线程同步方式

- 互斥锁：只有一个线程能够持有锁，阻塞其他所有线程，保证同一时间只有一个线程能够操作资源
  - synchronized
  - Lock
- 读写锁：由读、写操作区分读锁与写锁，读锁可以由多个线程持有，写锁只能由一个线程持有
  - ReentrantReadWriteLock
- 信号量：由信号量来确定同时能有多少线程操作资源
  - 生产者-消费者模型
- 屏障：类似同步点，线程执行至屏障处会阻塞，直到所有线程都到达屏障后才能继续执行
  - CountDownLatch
  - CyclicBarrier
- 事件：使用 notify/wait 来控制线程访问，便于实现多线程优先级的比较操作
  - Condition

### PCB

Process Control Block，进程控制块，操作系统创建进程时会分配 pid 与对应的 PCB，用于获取/管理进程信息

- 进程描述信息：进程名、标识符
- 进程运行信息：进程阻塞原因、进程状态(READY/RUNNING/BLOCK/WAIT/CANCEL)、进程优先级
- 进程占用的资源：进程打开的文件、需求的 CPU 时间、内存空间、I/O 资源

### 进程状态

- NEW：进程刚被创建出来
- READY：进程准备好运行所需的资源，等待 CPU 分配
- RUNNING：进程被 CPU 执行
- WAITING：进程等待运行所需的资源(锁/CPU)而阻塞
- TERMINATED：进程结束/中断退出运行

![进程状态图转换图](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/state-transition-of-process.png)

### 进程通信

进程之间是独立的，要实现进程间通信必须依赖系统的内核作为中间人处理，即在内核中开辟缓冲区，两个进程通过对其读写实现通信

![](https://upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)

#### 匿名管道

在具有亲缘关系的进程(父子、兄弟)之间，通过内核缓冲区的读写进行通信

![](https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip|imageView2/2/w/228/format/webp)

- 单向通信：数据只能向一个方向流动，双方读写必须建立两个管道
- 亲缘关系：只能在父子、兄弟进程间使用
- 独立的文件系统：管道本质是缓冲区，对进程而言就是在文件中进行读写，管道不是普通的文件，不属于某种文件系统，而是单独构成一种文件系统，只存在于内存中
- FIFO：写入的数据在管道尾部，读取的数据在管道头部，不能随意更改读写的位置

管道本质上是一个 FIFO 循环队列的缓冲区，使用类似生产者-消费者模型来处理缓冲区已满/已空的情况(已满时阻塞生产者，已空时阻塞消费者，在处理后唤醒)

阻塞问题：无名管道无需显式打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。

- 当前进程向匿名管道的一端写数据，必须确定另一端有某一进程
- 若写入匿名管道的数据超过其最大值，写操作将阻塞
- 若管道中没有数据，读操作将阻塞
- 若管道发现另一端断开，将自动退出

缺点：

- 单向
- 亲缘
- 有限：管道存在于内存中，创建时为缓冲区分配一个页面大小
- 匿名
- 格式：管道传输的是无格式字节流，需要双方事先约定好数据格式(一个消息/命令/记录包含多少字节)

#### 有名管道

通过以文件形式将缓冲区放在文件系统中，得到一条访问路径，即使没有亲缘关系的进程也能通过路径来对缓冲区进行读写

有名管道也是严格遵守 FIFO

阻塞问题：有名管道在打开时需要确定对方的存在，否则将阻塞

- 以读方式打开管道，在此之前必须一个进程以写方式打开管道，否则阻塞
- 以读写方式打开有名管道，即以当前线程读，当前线程写，不会阻塞

#### 信号(Signal)

信号是 Linux 系统中用于进程间通信的一种机制，信号的发送方不需要关注接受方的状态(任何时候都可以发送)

若接收方未处于执行状态(READY/WAITING)或阻塞信号的接收，则由内核保存信号，直到接收方开始执行时再传递；若接收方已退出(TERMINATED)，则内核直接丢弃信号

信号是**软件层次上对中断机制的模拟**，是一种**异步通信**方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发送了哪些系统事件，信号的产生可以是硬件的输入(ctrl + c，硬件异常，无效的存储访问)，或软件指令(kill)

信号的生命周期：

1. 发送方生成信号，设置接收方信息(pid)，传递给操作系统
2. 操作系统根据接收方状态选择性地发送
   - 阻塞：内核保存信号，等待接收方解除阻塞
   - 执行：内核传递信号
   - 退出：接收方进程已退出，则内核直接丢弃信号
3. 接收方收到内核传递的信号，中断当前执行的程序，保存上下文(寄存器数据、程序执行位置、CPU 状态)，根据信号中设置的预处理方式执行中断服务程序，完成后恢复到中断的位置

#### 消息队列

消息队列是存放在内核中的消息链表，每个消息队列都有一个消息队列标识符

- 存储：消息队列存放在内核中，只有内核重启、手动删除才会被删除
- 访问：消息队列遵循 FIFO 原则，但也能实现随机访问
- 使用：消息队列不需要读写双方的注册，即不同于管道，消息队列的写操作不需要另一个进程在队列等待消息到达
- 并发：消息队列支持多个进程读写
- 对比：
  - 管道：传输的信息具有特定的格式(管道为无格式字节流)，不受缓冲区大小限制，读写双方独立进行
  - 信号：能够传输更多信息量

#### 共享内存

进程间直接读写同一块内存空间，即内核中专门开辟一块内存区，进程将该内存地址映射到自己的私有地址空间，之后通过直接修改内存数据进行通信，而不需要进行数据拷贝，是**效率最高的通信方式**，需要额外的同步方式确保同步安全(信号量)

![](https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)

#### 信号量

信号量是一个计数器，用于多线程访问共享数据时的进程间同步

为了获取共享资源，进程需要：

1. 创建信号量：调用者指定初始值
2. 等待信号量：测试信号量的值，若小于 0 则阻塞(P 操作)
3. 挂出信号量：将信号量的值加 1(V 操作)

P/V 操作都是原子操作，故信号量通常在内核实现

![两个进程使用一个二值信号量](https://upload-images.jianshu.io/upload_images/1281379-376528c40d03717e.png?imageMogr2/auto-orient/strip|imageView2/2/w/635/format/webp)

![两个进程使用一个 Posix 有名二值信号量](https://upload-images.jianshu.io/upload_images/1281379-a72c8fbe22340031.png?imageMogr2/auto-orient/strip|imageView2/2/w/613/format/webp)

![一个进程两个线程共享基于内存的信号量](https://upload-images.jianshu.io/upload_images/1281379-a1b276fae9db985d.png?imageMogr2/auto-orient/strip|imageView2/2/w/284/format/webp)

##### 信号量 vs 互斥量

- 用途：
  - 互斥量用于线程的互斥，保证同一时间只有一个线程能够操作资源，具有唯一性与排他性，但无法限制访问顺序(无序)
  - 信号量用于线程的同步，在互斥的基础(大多数情况)通过其他机制实现访问者对资源的有序访问

#### 套接字(socket)

socket 是一种通信机制，客户/服务器(进行通信的进程)系统的开发工作既可以在本地单机进行，也可以跨网络进行，即可以让两个计算机进程通过网络连接

![Socket 是应用层和传输层之间的桥梁](https://upload-images.jianshu.io/upload_images/1281379-2db1deb0115ec4f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/319/format/webp)

socket 是 TCP/IP 通信的基本操作单元，不同主机间的进程进行双向通信的端点，通信双方通过 socket 中的相关函数完成通信过程

socket 由 3 个属性确定：域、端口号、协议类型

##### 域

指定 socket 通信中的网络介质：

- AF_INET：Internet 网络，需要服务器的 IP 和端口号指定一台联网机器上的某个特定服务，所以在使用 socket 作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接
- AF_UNIX：UNIX 文件系统，即文件的输入/输出，以文件名为地址

##### 端口号

每个基于 TCP/IP 网络通信的进程都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留 socket 中的输入/输出信息，端口号用于区别主机上的每个进程

每个 socket 通过组合进程 IP 和端口来区别

##### socket 协议类型

Internet 提供 3 种通信机制：

- 流套接字：在域中通过 TCP/IP 连接实现，也是 AF_UNIX 中常用的类型。流套接字提供一个**有序、可靠、双向字节流**的连接，可以确保发送的数据不会丢失、重复、乱序，且有一定的出错重传机制
- 数据包套接字：不需要建立与维护连接，在域中通过 UDP/IP 协议实现。对可发送的数据长度有限制，数据包作为单独的网络消息被传输，可能丢失、重复、乱序，即 **UDP 不是一个可靠的协议，但是效率更高(不需要建立连接)**
- 原始套接字：**允许对较低层次的协议直接访问**(IP、ICMP)，常用于检验新的协议实现，或访问现有服务中配置的新设备，因为原始套接字能够自如地控制 Windows 下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字操作网络层和传输层应用
  - 原始套接字可以读写内核没有处理的 IP 数据包，流套接字只能读取 TCP 协议的数据，数据套接字只能读取 UDP 协议的数据

##### socket 通信的建立

- 服务器：
  1. 服务器应用程序通过系统调用创建一个 socket，它是系统分配给服务器进程的类似文件描述符的资源，不能与其他进程共享
  2. 进程给 socket 命名(系统调用 bind)后开始等待客户连接到该 socket
  3. 系统调用 listen 来创建队列，用于存放来自客户的连接
  4. 服务器通过系统调用 accept 接受客户连接，创建一个与原有的命名 socket 不同的新 socket，该 socket 只用于与这个特定客户通信，而命名 socket(原 socket) 保留下来继续处理来自其他客户的连接
- 客户端：
  1. 客户应用程序首先调用 socket 创建未命名 socket，将服务器的命名 socket 作为地址来调用 connect 与服务器建立连接
  2. 建立连接后可以像使用底层的文件描述符一样用 socket 实现双向数据的通信(通过流进行数据传输)

![socket 通信基本流程](https://upload-images.jianshu.io/upload_images/1281379-2575b81bbab6b67b.png?imageMogr2/auto-orient/strip|imageView2/2/w/437/format/webp)