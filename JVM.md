# JVM

JVM 是一个虚构出来的计算机，一种规范，通过在实际的计算机上仿真模拟各类计算机功能实现

## Java 5 大块

- 类加载器：用于加载 .class 文件到 JVM 中
- 方法区：存放元信息(类信息，常量，静态变量，JIT 优化缓存)
- 堆：存放几乎所有对象，与方法区都是线程共享(线程不安全)
- 栈：调用方法会在栈中运行
- 程序计数器：线程内的程序计数器，用于记录代码运行到哪里，与栈一样是线程独享的

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/9/16f8ab42da5a81cd~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

### Java 文件运行流程

1. 编译 .java 文件后执行，JVM 会启动一条线程
2. 类加载器在 classpath 路径下将对应的 .class 文件加载到 JVM，相应的类信息存入运行时数据区的方法区
3. JVM 找到主程序入口执行 main 方法
4. 对于 new 操作：
   1. 先将对应的 .class 文件加载
   2. 在堆中分配内存空间
   3. 调用构造函数初始化
   4. 生成的实例持有指向方法区中的对应类信息的引用
5. 执行实例方法：
   1. 由引用找到堆中的类实例
   2. 由实例持有的类信息引用找到对应方法的字节码地址(方法表)
   3. 执行对应方法

### 对象的创建

1. 检查类是否已加载：检查 new 指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过，没有则必须先执行相应的类加载过程
2. 分配内存：通过类加载检查后，JVM 为新生对象分配内存(大小在类加载过程中可知)
   - 分配方式：
     - 指针碰撞：适用于内存规整的情况(Serial/ParNew)，由一个指针划分已用与未用两块内存，分配内存只需要将指针移动相应大小的位置即可
     - 空闲列表：适用于内存不规整的情况(CMS)，由一个列表统计所有可以内存块的大小，在其中选择合适的区域分配后更新列表
   - 并发冲突：堆内存是线程共享的，分配内存是线程不安全的
     - CAS + 重试：由 CAS 操作尝试获取内存，失败则重试
     - TLAB：JVM 事先为所有线程分配内存空间，不够时再通过 CAS 操作尝试获取新的内存空间
3. 初始化零值：将分配到的内存中的值置零(除了对象头)，保证对象的实例字段在 Java 代码中可以不赋初始值就直接使用
4. 设置对象头：设置对象的元信息(指向类元数据的指针、哈希码、GC 分代年龄等)
5. 执行 init 方法：此时从 JVM 角度对象已创建，但还需要执行 init 方法来初始化为 Java 程序可用的对象(显示初始化，构造函数)

### 对象的内存布局

- 对象头
  - 存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志
  - 类型指针：指向类元数据的指针，用于确定实例对象属于哪个类
- 实例数据：对象真正存储的有效信息
- 对齐填充：不是必然存在，只用于占位，因为 Hotspot 的自动内存管理要求对象起始地址必须是 8 字节的整数倍

### 对象的访问定位

Java 程序通过栈上的 reference 数据来操作堆上的具体对象，对象的访问方式由虚拟机实现

- 句柄：Java 堆中划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息
  - 使用句柄时，reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，reference 不需要修改
- 直接指针：reference 中存储的直接就是对象的地址
  - 使用直接指针时速度更快，因为它节省了一次指针定位的开销

## 类加载器

类加载器只负责将 .class 文件的字节码内容加载到 JVM，将其转换为方法区中的运行时数据结构，并不关心加载的类是否能够运行

### 类加载流程

1. 加载：每个 Java 类都有一个引用指向加载它的 ClassLoader，但数组类不通过 ClassLoader 创建，而是 JVM 在需要时自动创建，数组类通过 getClassLoader() 方法获取 ClassLoader 时与其元素类型的 ClassLoader 一致
   1. 通过全类名获取定义此类的二进制字节流
   2. 将 .class 文件加载进内存，转换为运行时数据结构存储在方法区
   3. 在堆中生成对应的 Class 对象，作为访问方法区中类元数据的入口
2. 链接：
   1. 检查：检查类是否符合 JVM 规范，类方法是否会产生危害 JVM 的行为，包含文件格式(.class 文件)、元数据(字节码语义)、字节码(程序语义)、符号引用(类的正确性)验证，其中除了文件格式验证基于类的二进制字节流进行，保证输入的字节流能正确地解析并存储于方法区，其余三个都是基于方法区的存储结构进行
      - 对信任的代码可以使用 -Xverify:none 参数关闭大部分的类验证措施，以缩短虚拟机类加载时间
   2. 准备：类静态变量的内存分配与初始化(默认值)
      - 在 Java 7 及之前内存分配至方法区的永久代中，在 Java 8 后分配至堆中的静态变量
   3. 解析：将常量池内的符号引用(字面量)替换为实际引用(即将 apple 替换为对象实际的内存地址)
3. 初始化：执行初始化方法 `<clinit>()`，由 JVM 保证线程安全(难以发现的阻塞)，只有以下 6 种情况才会初始化类
   - new、getstatic、putstatic、invokestatic 四条字节码指令
     - new：创建类的实例对象
     - getstatic：访问类的静态变量(静态常量会存储到运行时常量池，此处为类的静态变量)
     - putstatic：给类的静态变量赋值
     - invokestatic：调用类的静态方法
   - 反射：对类进行反射调用(Class.forName、newInstance)
   - 父类未初始化
   - JVM 启动时，用户需要定义一个要执行的主类(main 入口)，JVM 会先初始化这个类
   - MethodHandle 和 VarHandle 可以看作轻量级的反射调用机制，使用前要先用 findStaticVarHandle 来初始化要调用的类
   - 接口中定义了 Java 8 新加入的默认方法(default)，该接口的实现类初始化时，接口要在其之前被初始化
4. 使用
5. 卸载：GC 回收
   - 实例：类的实例对象都被回收
   - Class 对象：类的 Class 对象被回收(不可通过反射再生成实例)
   - 类加载器：类加载器的实例被回收

### 类加载器的加载顺序

1. Bootstrap：启动类加载器，主要用于加载 JDK 内部的核心类库
   - %JAVA_HOME%/lib 目录下的 rt.jar、resources.jar、charsets.jar 等 jar 包和类
     - rt.jar 表示 runtime，是 Java 基础类库
   - 被 -Xbootclasspath 参数指定的路径下的所有类
2. Extension：扩展类加载器，Java 9 中引入模块系统，扩展类加载器改名为平台类加载器(platform class loader)，Java SE 中除了少数几个关键模块(java.base)由启动类加载器加载，其他模块均由平台类加载器加载
   - %JRE_HOME%/lib/ext 目录下的 jar 包和类
   - java.ext.dirs 系统变量所指定的路径下的所有类
3. App：当前应用 classpath 下所有 jar 包和类的加载器
4. Custom：自定义加载器，可以通过重写 loadClass(String name, boolean resolve) 方法打破双亲委派机制

除了 BootstrapClassLoader 是 JVM 的一部分(由 C++ 实现)外，其他所有类加载器都是在 JVM 外部实现的，且都继承自 ClassLoader 抽象类

### 双亲委派机制

在一个类需要加载时，首先调用底层的类加载器(根加载器，加载器的父类)，若无法加载再逐层调用子加载器

由此可以确保不同的类加载器加载的结果一致，且用户自定义的类不会覆盖 JDK 自身的类

不同的类：全类名与类加载器都不同

1. 判断类是否已被加载
2. 调用父加载器(由组合实现) loadClass() 方法来加载类，即所有请求最终都传送到启动类加载器
3. 父加载器无法完成加载请求时，子加载器才尝试去加载
4. 子加载器也无法加载时抛出 ClassNotFoundException 异常

#### 父类加载器依赖子类加载器完成加载

单纯依靠自定义类加载器无法满足某些场景的要求，有些情况下高层的类加载器需要加载低层的加载器才能加载类

如：Spring 的 jar 包是 Web 应用间共享的，因此由 SharedClassLoader 加载(Web 服务器为 Tomcat)。项目中用到了 Spring 的业务类(实现 Spring 提供的接口、用到 Spring 提供的注解)，此时加载 Spring 的类加载器(SharedClassLoader)也会用于加载这些业务类。但业务类处于 Web 应用目录下，SharedClassLoader 无法找到，即无法加载。

故 Spring 加载业务类时，不使用自己的类加载器，而是用当前线程的上下文类加载器。每个 Web 应用都会创建一个单独的 WebAppClassLoader(Tomcat)，并在启动 Web 应用的线程里设置线程上下文类加载器为 WebAppClassLoader。高层的类加载器(SharedClassLoader)由此可以借助子类加载器(WebAppClassLoader)来加载业务类，破坏了双亲委派机制

#### 线程上下文类加载器

将一个类加载器保存在线程私有数据中，跟线程绑定，在需要时取出使用，该类加载器通常是由应用程序或容器(Tomcat)设置

Java.lang.Thread 中的 getContextClassLoader() 和 setContextClassLoader(ClassLoader cl) 分别用于获取和设置线程的上下文类加载器。若没有通过 setContextClassLoader(ClassLoader cl) 进行设置，则会直接继承父线程的上下文类加载器

## 运行时方法区

![Java 运行时数据区域（JDK1.7）](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png)

![Java 运行时数据区域（JDK1.8 ）](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)

### 程序计数器

指向下一条字节码指令行号的指针，JVM 通过改变程序计数器来**选取下一条需要指向的字节码指令**

为了多线程切换时能够**恢复到正确的执行位置**，程序计数器是线程私有的

程序计数器是内存空间中唯一不会出现 OOM 的区域，且在执行 native 方法时无效

### 本地方法栈

存放 native 方法的栈，包含本地方法的局部变量表、操作数栈、动态链接、方法出口

### 方法区

存放元信息的内存区域，如：类信息、方法信息、静态变量、JIT 优化缓存、常量等

#### 运行时常量池

存放编译器生成的各种字面量(由其字面可以知道其值的含义，如整数、浮点数、字符串字面量)和符号引用(类、字段、方法引用)

#### 字符串常量池

字符串是会被频繁使用的变量，为了避免频繁创建相同的字符串对象，JVM 中为已创建的字符串对象分配了字符串常量池，当需要使用相同的字符串字面量时可以直接从字符串常量池中复用对象

字符串常量池的底层是使用哈希表进行存储

- Java 7 及之前：字符串常量池存放在方法区的永久代
- Java 8 及之后：字符串常量池与静态变量移至堆中
  - 因为永久代的 GC 效率低(只有 Full GC)，导致字符串常量池中会遗留大量不再使用的字符串常量

### 虚拟机栈

虚拟机栈是方法运行的内存模型，会存储方法的局部变量表、动态链接、方法出口、入栈出栈操作

![Java 虚拟机栈](https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png)

- 局部变量表：存放编译期可知的各种数据类型、对象引用

- 操作数栈：方法调用的中转栈，用于存放计算的中间结果、计算产生的临时变量

- 动态链接：方法内调用其他方法时，需要将字面量转换为实际方法在内存地址的直接引用

  ![](https://oss.javaguide.cn/github/javaguide/jvmimage-20220331175738692.png)

方法在 return 与抛出异常时都会出栈，在超出栈容量时抛出 StackOverFlowError，在扩大栈容量时可能抛出 OutOfMemoryError

#### 生命周期

方法执行完毕后出栈，相关内存空间自动释放，故不需要 GC

基本数据类型、逃逸分析、对象引用、实例方法都存储在栈中

#### 执行

方法通过栈帧的形式存储在虚拟机栈中，方法开始执行即入栈，结束执行即出栈，栈的操作符合先入后出的规则

#### 局部变量表的复用

局部变量表用于按照特定顺序存储方法参数与局部变量，其存储的单位为小于 32 位的 slot，当存储的变量超过其作用域(不再被使用)时，该 slot 可以被其他变量重用，垃圾回收器不会回收此内存

### 虚拟机堆

堆主要用于存储实例对象

JVM 内存区域：

![堆内存结构](https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png)

- 堆：
  - 新生代
    - Eden
    - Survivor
      - FromPlace
      - ToPlace
  - 老年代
- 非堆:
  - 永久代(Java 8 后移除) --> 元空间(直接使用系统内存中)
    - 主要是为了和 JRockit VM 合并，但也解决了永久代频繁 OOM 的问题(难以设置永久代的大小，加载大量类时容易 OOM，使用本机内存只会受到物理内存的限制)

#### 新生代

创建的对象实例会先存放于年轻代的 Eden 区

当 Eden 区的对象存活过(经历 Mirror GC 且能够被 Survivor 容纳)足够多次(最多 15，Hotspot 分配的记录空间 Age 只有 4 位，具体默认值由回收器决定)的 GC 后，会将其移至老年代

##### TLAB

由于堆内存是线程共享的，所以可能会出现多个线程共享一块内存的情况，故 JVM 会为每个线程提前分配一块连续的内存使用，当这块内存用完后再申请

##### Mirror GC

当 Eden 区满时会触发 Mirror GC，将 Eden 区的存活对象移至 Survivor0 区；当 Survivor0 区已满，则对 Eden 区与 Survivor0 区的对象进行可达性分析，将有效的对象移至 Survivor1 区，再对 Eden 区与 Survivor0 区 GC 后将 Survivor1 区与 Survivor0 区交换(交换 from 与 to 指针)

##### 分配担保机制

分配担保机制会在 Mirror GC 前确认老年代中最大的连续内存是否大于新生代所有对象总和，成立则可以确保此 Mirror GC 是一定成功的，否则需要确认 JVM 是否允许担保失败(-XX:HandlePromotionFailure)

担保失败会检查新生代中所有对象大小是否小于历次晋升的新生代对象大小的平均值，大于则进行有风险的 Mirror GC，否则需要 Full GC

#### 老年代

##### 大对象

需要占用大量连续内存的对象(数组、字符串)会直接进入老年代，避免占用大量新生代内存而导致频繁的 Mirror GC。是否为大对象由垃圾回收器判断：

- G1 回收器：通过设定的堆大小及阈值参数判断
- Parallel Scavenge 回收器：通过当前堆内存使用情况及历史数据动态判断大对象的大小

##### 动态年龄

Hotspot 遍历所有对象时，若某个年龄占用的内存占比超过阈值(50%)，则取该年龄与设定的阈值年龄中的更小值作为新的晋升年龄阈值

##### Old GC

只对老年代进行收集

##### Full GC

老年代的内存满后会触发 Full GC，此时 JVM 的所有线程都会暂停，直到 Full GC 完成

若 Full GC 后仍不够内存，则会抛出 OOM 错误

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa201c39ac86ad~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

### 垃圾回收

程序计数器、虚拟机栈、本地方法栈等线程私有的区域生命周期随线程结束而消亡，故不需要特意回收

堆、方法区等线程共享的区域则需要使用垃圾回收器进行 GC

#### 如何判断需要回收

- 引用计数器：每个对象维护自身的引用计数，每有一个引用则加 1，引用失效时减 1，计数器为 0 时表示对象无效。
  - 循环引用时失效
- 可达性分析：类似树结构，从起始的存活对象集 GC Roots 开始，搜索所走过的路径成为引用链，把能被集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，说明对象不可用
  - 可以规避循环引用，但搜索会耗费大量性能，且需要停止所有线程(引用关系不可修改)

#### finalize()

finalize() 为 Obejct 类的方法，一个对象的 finalize() 只会被调用一次，经过 finalize() 后仍存活的对象也不会再调用

finalize() 执行的时间不确定，是否执行也不确定(Java 程序的不正常退出)，且运行开销大，无法保证各个对象的调用顺序。在 Java 9 中已被标记为 deprecated，且逐步被 Cleaner 取代

#### 判断可以回收

#####  对象

判断对象可以回收(死亡)需要两次标记

1. 经过可达性分析发现对象没有与 GC Roots 的引用路径，则将对象进行标记且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()，即是否有重写的 finalize() 方法需要执行，若需要则加入 F-Queue 队列，否则直接回收
2. GC 对 F-Queue 队列中的对象进行二次标记，若在 finalize() 方法中重新与引用链上的对象建立关联，则将其移出队列，否则进行回收(已经执行过一次 finalize() 方法，即自救过一次的也会直接回收)
   - GC Roots：
     - 栈对象：局部变量表，本地方法栈引用的对象
     - 类静态属性引用的对象
     - 常量引用的对象
     - 被同步锁持有的对象
     - JNI 引用的对象

##### 常量

常量没有任何引用时即会在必要时被回收

##### 类

- 堆中不存在类的实例
- 类的加载器 ClassLoader 已被卸载
- 堆中类的 Class 对象没有引用(不会通过反射创建类实例)

满足上述三种条件时，类可以被回收(不保证执行)

#### 垃圾回收算法

##### 标记-清除算法

将需要回收的对象标记，再统一进行清除

实现简单，但标记与清除操作都需要**耗费大量性能**，且清除后会残留大量的**碎片空间**

流程：

1. 创建对象，标记为 0
2. 可达性分析时将可达对象标记为 1
3. 清理所有标记为 0 的对象

##### 复制算法

**将内存分为对等的两块**，每次只使用其中一块，发送 GC 时将所有存活对象复制到另一块内存，再将当前内存全部清除

解决了标记清除后产生大量碎片内存的问题，也不需要单独回收需要清理的对象

但可用内存只有实际的一半，且存活大量对象(老年代)时性能下降

##### 标记-整理算法

在标记-清除的基础上先整理残留的碎片空间，即将要回收的对象都移至边缘，再统一清理，适用于老年代(有大量存活对象，只有少量被回收)

由于新增了整理步骤，故性能比标记-整理更差，适用于 GC 频率不高的场景(老年代)

##### 分代收集算法

综合整理上述算法，针对不同情景使用不同的收集算法

- 新生代：频繁创建对象，对象较小且存活时间不长，故可用标记-复制算法，只需要将少量存活的对象复制出来，再清理掉大量死亡的对象
- 老年代：存活对象较多，且对象较大，没有额外的空间进行担保，故只能使用标记-清除或标记-整理算法

Hotspot 中区分新生代与老年代就可以方便地采用不同的垃圾收集算法，提高 GC 效率

#### 垃圾收集器

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/15/16fa60ac474394f7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

- 响应速度/停顿时间优先：令每次为了 GC 停顿的时间变短，如此会减少 GC 回收量，导致频繁 GC，即 GC 时间占总运行时间的比例高
- 吞吐量优先：吞吐量 = 运行应用代码时间 / (运行应用代码时间 + GC 时间)，在单位时间内令 GC 的时间占比变少就要使用更长的时间来进行更彻底的 GC，从而减少 GC 的频率

Java 8 中的默认垃圾回收器为：Parallel Scavenge 与 Parallel Old

Java 9 开始使用 G1 收集器为默认的垃圾回收器

##### Serial 收集器

只有一条垃圾回收线程，且在 GC 过程中会暂停其他所有线程，实现简单，且相较于其他单线程收集器效率更高，适用于 Client 模式的虚拟机

- 新生代：标记-复制
- 老年代：标记-整理

##### ParNew 收集器

Serial 的多线程版本，是 Server 模式的首选项，只有 ParNew 与 Serial 能与 CMS 配合使用

- 新生代：标记-复制
- 老年代：标记-整理

##### Parallel Scanvenge 收集器

专注于提高吞吐量的收集器，与 ParNew 类似，提供大量参数平衡吞吐量与停顿时间

- 新生代：标记-复制
- 老年代：标记-整理

##### Serial Old 收集器

Serial 收集器的老年代版本，主要用于：

- Java 5 及之前配合 Parallel Scanvenge 收集器处理老年代的回收
- 作为 CMS 收集器的备用方案

##### Parallel Old 收集器

Parallel Scanvenge 的老年代版本，适用于注重吞吐量与 CPU 资源的场景

##### CMS 收集器

Concurrent Mark Sweep 收集器，是 Hotspot 的第一款真正意义的并发收集器，让 GC 线程基本上与用户线程同时工作，其主要步骤为：

- 初始标记：暂停用户线程，简单标记与 GC Roots 直接相连的对象，暂停时间短
- 并发标记：GC 线程与用户线程同时运行，通过可达性分析标记需要回收的对象，使用闭包结构记录
- 重新标记：暂停用户线程，重新标记在并发期间可能产生改变的对象，暂停时间长于初始标记阶段，但远远小于并发标记阶段
- 并发清除：GC 线程与用户线程并发，清理未标记的区域

CMS 极大地减少了停顿时间，适用于注重用户体验的场景，但也有如下缺点：

- CPU 资源敏感：需要 GC 线程与用户线程并发
- 无法清理浮动垃圾：在初始标记时标记为存活的对象，在并发标记阶段死亡，但在重新标记阶段无法纠正，即不会被回收，需要等待下次 GC
- 底层使用标记-清除算法，产生大量碎片空间

##### G1 收集器

Garbage-First 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征

- 并行与并发：利用多核 CPU 缩短 Stop-The-World 停顿时间，部分其他收集器需要停顿执行的 GC 动作仍可以通过并发的方式让用户线程继续执行
- 分代收集：G1 虽然不需要依赖其他收集器就能独立管理堆，但仍保留了分代收集的概念
- 空间整合：G1 在整体使用了标记-整理算法，在局部使用的是标记-复制算法
- 可预测的停顿：G1 能够令用户规定在 M 毫秒内 GC 停顿的最大时长 N 毫秒
  - Garbage-First：在后台维护优先列表，每次在允许时间内选择回收价值最大的 Region，保证在有限时间内的最大回收效率

##### ZGC 收集器

通过改进标记-复制算法，令 STW 的情况更少

## JVM 调优

### 堆内存

#### 显示指定堆内存 -Xms 和 -Xmx

根据应用程序要求初始化堆内存

- -Xms：最小堆大小 -Xms2G
- -Xmx：最大堆大小 -Xmx5G

#### 显式指定新生代内存大小

在堆总可用内存配置完成之后，第二大影响因素是新生代在堆内存所占比例

默认情况下，新生代最小为 1310MB，最大无限制

- -XX:NewSize 与 -XX:MaxNewSize 指定：

  ```bash
  -XX:NewSize=256m 
  -XX:MaxNewSize=1024m
  ```

- -Xmn 指定：NewSize == MaxNewSize

  ```bash
  -Xmn<young size>[unit]
  -Xmn256m
  ```

因为 Full GC 的开销远大于 Mirror GC，故应尽量将新创建的对象存放在新生代。根据 GC 日志分析新生代大小是否合理，通过 -Xmn 调整新生代大小来减少新对象直接进入老年代的情况

- -XX:NewRatio 用于设置老年代与新生代的比例

#### 显示指定永久代/元空间大小

元空间直接使用系统内存，且默认无上限，故频繁创建类可能会耗尽系统内存

- 永久代：

  ```bash
  -XX:PermSize=N # 方法区(永久代)初始大小
  -XX:MaxPermSize=N # 方法区(永久代)最大大小
  ```

- 元空间：

  ```bash
  -XX:MetaspaceSize=N # 元空间的初始大小是固定的，该参数用于设置元空间发生 Full GC 的阈值
  -XX:MaxMetaspaceSize=N # 元空间的最大大小
  ```

### 垃圾收集

#### 垃圾回收器

定义 JVM 使用的垃圾回收器

```bash
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseParNewGC
-XX:+UseG1GC
```

#### GC 日志

生产环境，或测试 GC 问题的环境上，会配置打印 GC 日志的参数，便于分析 GC 相关问题

```bash
# 必选
# 打印基本 GC 信息
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
# 打印对象分布
-XX:+PrintTenuringDistribution
# 打印堆数据
-XX:+PrintHeapAtGC
# 打印Reference处理信息
# 强引用/弱引用/软引用/虚引用/finalize 相关的方法
-XX:+PrintReferenceGC
# 打印STW时间
-XX:+PrintGCApplicationStoppedTime

# 可选
# 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

# GC日志输出的文件路径
-Xloggc:/path/to/gc-%t.log
# 开启日志文件分割
-XX:+UseGCLogFileRotation
# 最多分割几个文件，超过之后从头文件开始写
-XX:NumberOfGCLogFiles=14
# 每个文件上限大小，超过就触发分割
-XX:GCLogFileSize=50M
```

### 处理 OOM

JVM 提供了一些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏

```bash
-XX:+HeapDumpOnOutOfMemoryError # JVM 在遇到 OOM 时将 heap 转储到物理文件
-XX:HeapDumpPath=./java_pid<pid>.hprof # 表示要写入的文件，若 JVM 在名称中找到一个 <pid> 标记，则当前进程的进程 id 将附加到文件名中，并使用 .hprof 格式
-XX:OnOutOfMemoryError="< cmd args >;< cmd args>" # 用于发出紧急命令，以便在内存不足的情况下执行，如 -XX:OnOutOfMemoryError="shutdown-r" 在 OOM 时重启服务器
-XX:+UseGCOverheadLimit # 限制在抛出 OOM 之前在 GC 中花费的 VM 时间比例
```

### 其他

- `-server` : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM
- `-XX:+UseStringDeduplication` : _Java 8u20_ 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 `char []` 数组来优化堆内存。
- `-XX:+UseLWPSynchronization`: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。
- `-XX:LargePageSizeInBytes`: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。
- `-XX:MaxHeapFreeRatio` : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。
- `-XX:SurvivorRatio` : eden/survivor 空间的比例, 例如`-XX:SurvivorRatio=6` 设置每个 survivor 和 eden 之间的比例为 1:6。
- `-XX:+UseLargePages` : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。
- `-XX:+UseStringCache` : 启用 String 池中可用的常用分配字符串的缓存。
- `-XX:+UseCompressedStrings` : 对 String 对象使用 `byte []` 类型，该类型可以用纯 ASCII 格式表示。
- `-XX:+OptimizeStringConcat` : 它尽可能优化字符串串联操作。

## JDK 命令行工具

- jps：查看所有 Java 进程
- jstat：监视虚拟机各种运行状态，可以显示本地/远程虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据
- jinfo：实时查看和调整虚拟机各项参数
- jmap：生成堆转储快照
- jhat：分析 heapdump 文件
- jstack：生成虚拟机当前时刻的线程快照，定位线程长时间出现停顿的原因(线程间死锁、死循环、请求外部资源)，通过 jstack 查看各个线程的调用堆栈，可以知道未响应的线程在后台做什么/等待什么

