# 高性能

## CDN

Content Delivery/Distribution Network，内容分发网络：

- 内容：静态资源，如图片、视频、文档、JS、CSS、HTML
- 分发网络：将静态资源分发到位于多个不同地理位置的机房中的服务器上，==实现静态资源的就近访问，加快静态资源的访问速度，减轻服务器以及带宽的负担==

CDN vs 全站加速：

- CDN 主要针对静态资源
- 全站加速既可以加载静态资源，又可以加载动态资源

CDN vs 部署服务器至多个地点：

- 将相同的服务部署在多个不同的地方成本太高
- 静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或缓存处理静态资源请求，对系统资源消耗较大，可能会影响到系统其他服务的正常运行

同一个服务在多个不同的地方部署多份(同城灾备、异地灾备、同城多活、异地多活)是为了实现系统的高可用而不是就近访问

### 工作原理

#### 静态资源如何缓存至 CDN 节点

静态资源加载至 CDN 节点有预热与回源两种方式：

- 预热：在 CDN 上提前将内容缓存到 CDN 节点上，当用户在请求这些资源时，能快速地从最近的 CDN 节点获取而不需要回源，进而减小对源站的访问压力，提高了访问速度
- 回源：当 CDN 节点上没有用户请求的资源或该资源的缓存已经过期时，CDN 节点需要从原始服务器获取最新的资源内容，这个过程就是回源，当用户请求发生回源，会导致该请求的响应速度比未使用 CDN 慢，因为多了一层 CDN 的调用流程

资源更新时，也可以进行==刷新==操作，删除 CDN 节点上缓存的旧资源，强制 CDN 节点回源站获取最新资源

命中率越高，回源率越低，CDN 服务质量越好

#### 找到最合适的 CDN 节点

GSLB(Global Server Load Balance，全局负载均衡)是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB

CDN 会通过 GSLB 找到最合适的 CDN 节点：

1. 浏览器向 DNS 发送域名请求
2. DNS 向根据 CNAME 别名记录向 GSLB 发送请求
3. GSLB 返回性能最好的 CDN 节点的地址给浏览器
4. 浏览器直接访问指定的 CDN 节点

![CDN 原理示意图](https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-overview.png)

GSLB 内部可以看作是 CDN 专用 DNS 和负载均衡系统组合，CDN 专用 DNS 会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点

GSLB 会根据请求的 IP 地址、CDN 节点状态(负载情况、性能、响应时间、带宽)等指标来综合判断具体返回哪个 CDN 节点的地址

#### 防止资源盗刷

==盗刷/盗链指在自己的页面上展示一些并不在自己服务器上的一些内容==，获取别人的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容，资源被非法盗刷会带来不小的开销

解决该问题最常用最简单的方法是==设置 Referer 防盗链==：根据 HTTP 请求的头信息里的 Referer 字段对请求进行限制，可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，由此确定请求是否来自合法网站

如果站点的防盗链配置允许 Referer 为空，通过隐藏 Referer 可以直接绕开防盗链，所以需要配合其他机制来确保静态资源不被盗用：

- 时间戳防盗链：加密的 URL 具有时效性，过期之后就无法再被允许访问，通常有两个参数
  - 签名字符串：通过对用户设定的加密字符串、请求路径、过期时间进行 MD5 加密
  - 过期时间

除此之外，还可以通过 IP 黑白名单、IP 访问限频配置等机制来防盗刷

## 数据冷热分离

数据冷热分离是根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在低成本、低性能的介质，热数据存储在高性能介质中

### 冷热数据

- 热数据：访问/修改频率高、需要快速访问
- 冷数据：不经常访问，对当前项目价值低，但需要长期存储

冷热数据一般通过访问频率或时间维度区分

### 优点

- 热数据查询得到优化，提升大多数用户的操作体验
- 节约成本，冷数据能够存储在低成本的介质中

### 缺点

- 系统复杂性和风险增加，需要分离冷热数据，数据错误的风险增加
- 统计效率低，可能需要用到冷数据

### 冷数据迁移

- 业务层代码实现：在写入数据时判断是否为冷数据，再存入不同的库中
  - 冷热数据逻辑判断难以确定
  - 业务代码侵入
- 任务调度：利用 xxl-job 或其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量迁移至冷库
  - 修改代码少
  - 适用于按时间区分冷热数据的场景(易于判断)
- 监听数据库的变更日志 binlog：将满足冷数据条件的数据从 binlog 中提取，迁移至冷库
  - 无需修改代码
  - 不适合按时间区分的场景
- 人工迁移

### 冷数据存储

冷数据存储要求主要是存储量大，成本低，可靠性高，可以适当牺牲访问速度

## 深度分页

查询偏移量过大的场景即深度分页，会导致查询性能较低

```sql
SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10
```

### 范围查询

保证 Id 连续的情况下可以根据 Id 范围进行分页

```sql
SELECT * FROM t_order WHERE id > 1000000 AND id < 10000010 ORDER BY id 
```

这种优化方式限制较大，一般无法保证 Id 的连续性

### 子查询

先查询除 limit 第一个参数对应的主键值，再根据这个主键值去过滤并 limit，由此减少回表

```sql
SELECT * FROM t_order WHERE id >= (SELECT id FROM t_order limit 1000000, 1) LIMIT 10
```

子查询的结果会产生一张新表，影响性能，应尽量避免大量使用子查询，且该方法只适用于 Id 正序，在复杂分页场景，往往需要通过过滤条件，从离散且不连续的 Id 中筛选