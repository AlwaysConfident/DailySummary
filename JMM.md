# JMM

Java 内存模型主要定义对一个共享变量的写操作是否对其他线程可见

## CPU 缓存模型

由于 CPU 处理速度远大于内存处理速度，所以使用 CPU Cache 对 CPU 的处理结果进行缓存

### 缓存一致性

在多线程情况下会出现内存缓存不一致的问题，即两个线程同时执行 i++，两者都从缓存中读到 i = 1，运算完成后两者写入缓存的结果为 i = 2，而正确结果应为 i = 3

CPU 为了解决内存缓存不一致的问题，可以制定缓存一致性协议(MESI 协议，定义四种状态来处理本地/共享读写时的状态转换)，不同的 CPU 使用的缓存一致性协议也不同

操作系统需要将底层硬件资源虚拟化，故也要实现缓存一致性协议(**内存模型**)

## 指令重排序

为了提高 CPU 执行效率，避免某个指令阻塞导致后续指令也被阻塞，故 编译器/CPU 会对指令在保证执行结果一致的情况下进行重排序

- 编译器优化：编译器(JVM，JIT 等)在保证执行结果不变的情况下重新安排指令的执行顺序
- 指令并行重排：现代处理器采用指令级并行技术(ILP)将多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

Java 源代码会经历 编译器优化重排 -> 指令并行重排 -> 内存系统重排 的过程，最终才变成操作系统可执行的指令序列

指令重排序会保证串行语义一致，但不保证多线程间语义一致，故对多线程需要：

- 编译器：通过禁止特定类型的编译器重排序方式来禁止重排序(volatile)
- 处理器：通过插入内存屏障的方式来禁止特定类型的处理器重排序
  - 内存屏障：一种 CPU 指令，用于禁止处理器指令发生重排序，从而保障指令执行的有序性。屏障类似于起点，即所有指令执行完毕后才能开始执行屏障后的指令

## Java Memory Model

由于 Java 是跨平台的语言，故不能复用操作系统自身的内存模型(避免字节码在不同平台无法运行)

JMM 可以看作 Java 并发编程的一组解决问题的规范，简化多线程编程与增强移植性

### JMM 抽象线程与主存的关系

JMM 中每个线程都有自己的工作内存，同时也共享一个主要内存。线程可以把变量保存在本地内存(寄存器)，而非直接在主存中进行读写

- 主存：存放所有线程新建的对象，包括成员变量、类信息、局部变量、静态变量、常量。为了提高效率，虚拟机和硬件系统可能会让工作内存优先存储于寄存器和高速缓存中
- 工作内存：线程私有的本地内存，存储线程已读/写共享变量的副本。私有即线程无法直接访问其他线程的本地内存，需要通过主存进行通信
  - 本地内存并不特指实际存在的硬件，只是 JMM 抽象的概念，涵盖了缓存、写缓冲区、寄存器及其他硬件和编译器的优化

#### 线程安全问题

线程间通信的基本步骤为：

1. 线程 A 将修改写入主存
2. 线程 B 从主存读取共享变量

即 JMM 需要为共享变量提供可见性保障

由于线程先将共享变量读取至工作内存，对副本修改后再写入主存，所以在多线程环境下会有线程安全问题，如：

- 线程 A 写入一个共享变量的同时线程 B 需要读取该变量，此时线程 B 读取的变量无法确定是否被 A 修改，因为无法确定 A 是否已将副本写回主存

故 JMM 定义了八种同步操作(加锁，解锁，读取，写入等)与相关规则来规范主存与工作内存的交互

#### Java 内存区域 vs JMM

- Java 内存区域与 JVM 的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，如堆用于存放对象实例
- JMM 是用于 Java 并发编程的一组规范，抽象了主存与工作内存的关系

#### happens-before

happens-before 表示一组规范，规定了哪些指令不允许重排序(哪些指令的执行结果对其后的指令是可见的，无论是否在同一个线程内)

happens-before 原则为程序员提供易于理解和编程的强内存模型的同时为编译器和处理器提供较少约束的弱内存模型

- 书写顺序：代码的书写顺序
- 锁顺序：加/解锁顺序
- volatile：volatile 变量的写操作结果对其后的读操作一定是可见的
- 传递规则：a -> b -> c 即 a -> c
- 线程启动顺序

若存在 happens-before 关系但重排序不影响执行结果时也会允许重排序，如

```java
int a = 1;
int b = 2;
int c = a + b;
// a 与 b 的赋值操作可以重排序
```

## 并发编程

### 原子性

一组操作要么一次性全部执行，要么全部失败

Java 中通过 synchronized、Lock、原子类实现原子性

- synchronized、Lock：保证只有一个线程访问代码块
- 原子类：利用 CAS 操作，volatile，final 关键字保证原子性

### 可见性

一个线程对共享变量的修改结果对其他线程是可见的

Java 中通过 synchronized、Lock、volatile 关键字实现

- volatile 修饰的变量
  - 读操作：先将工作内存中的副本设为无效，再从主存中读取
  - 写操作：直接将修改写入主存
- synchronized、Lock：确保只有一个线程执行代码块，并将执行结果写入主存

### 有序性

由于存在指令重排序的情况，代码的执行顺序并不一定按照书写顺序

指令重排序可以保证单线程情况下执行结果的有序性(重排序的执行结果同原顺序)，但不保证多线程下的有序性，如：

````java
boolean flag = false;
int val = 1;

void changeFlag(){
    val = 2;
    flag = true;
}

void changeVal(){
    if(flag){
        val = 3;
    }
}
// 线程 A 先执行 changeFlag
// 线程 B 后执行 changeVal
// 若线程 A 执行至 flag = true; 时阻塞，此时 flag = false
// 则线程 B 无法执行 val = 3;
// 若线程 A 重排序将 flag = true; 先执行，则线程 B 能够执行 val = 3;
// 此时重排序将影响执行结果
````

Java 中可以使用 volatile 保证有序性，即 volatile 关键字可以禁止指令的重排序

