## 分布式计算谬误

1. 网络延迟问题
   1. 消息丢失
   2. 超时导致重传和误判不在线
   3. 乱序
2. 带宽
3. 网络安全
4. 拓扑结构改变
5. 单一管理员
6. 传输成本
7. 网络是同构的
8. 部分失效
9. 时钟问题
   1. 每台机器的时钟不同
   2. 网络传输存在时延

## 两将军问题

两个将军需要同时进攻一处堡垒，但由于派出的信使可能被俘，所以都无法确信对方是否收到消息，导致即使重复发出确认的消息，仍然无法保证消息可靠

该问题表明节点之间只能通过消息传递来确认彼此的状态

工程解：TCP 的三次握手

## 拜占庭将军问题

两将军问题的延申，多个将军协商进攻/撤退，但可能存在叛徒故意散布假消息(发送矛盾的消息)，该问题的主要目的是令忠诚的将领在同一个计划达成共识

## 网络链路模型

网络设备出现故障，但节点仍正常工作，导致节点之间无法通信，形成网络分区

链路：

- 可靠链路：不会丢失，不会凭空生成消息，可能乱序
- 公平损失链路：可能丢失，可以通过重发升级为可靠链路
- 任意链路：可能丢失，也可能被攻击者篡改、伪造数据，通过 TLS 等手段升级为公平损失链路

## 节点故障模型

节点可能在发送/接收消息时出现故障，导致消息丢失

节点故障类型：

- 崩溃-停止：节点发生硬件上的故障导致崩溃，一般来说进程失败后就永久退出运行状态，不再加入系统
- 崩溃-恢复：节点故障后可以通过重启等手段恢复并重新加入系统，通常需要日志、检查点等持久化存储进行恢复
- 拜占庭问题：节点故障后可能会令算法偏移甚至故意破坏算法

## 时分模型

根据消息的响应时间分为同步/异步模型

- 同步：消息在一段可预知的时间内响应，简单但不可靠，因为节点和网络可能出现故障
- 异步：无法预知消息何时响应，基于异步的算法更加健壮，且适用于同步场景，但存在 FLP 不可能问题
- 部分同步

## 消息传递语义

由于网络/节点可能存在故障，导致消息丢失，故需要进行重发，但重发的多个消息可能被执行多次，虽然可以通过幂等操作令其只生效一次，但需要一直等待确认请求来保证每个操作都是幂等的，开销较大

通过消息的唯一标识来避免多次执行：

- At Most Once：消息严格传递一次，即使丢失也不重发
- At Least Once：消息至少发送一次，丢失后会重发
- Exactly Once：消息精确发送一次，不会丢失，也不会重发，不现实，通过忽略重发来达到该效果

# 分布式数据

随着数据量的激增，单机下的数据库无法存储并提供满足要求的性能，故需要将数据库进行分区再部署至多台机器

## 分区

分片即将原数据库表进行分割，根据分割方向不同有：

- 水平分区：保持表结构，将一张表的数据分成多张表
- 垂直分区：按表的列进行分割，由于表的列有限，故分割的子表也有限

垂直/水平分区在查询数据时需要联接多个节点中的数据，考虑到节点间通信会十分低效

## 水平分区算法

- 范围算法：取表中的一列作为索引，如年份，进行分割，将对应范围内的数据都存储到一个节点中
  - 简单易用
  - 可以/仅能对索引列进行范围查找
  - 数据可能分布不均，导致出现热点数据，如某一年的数据激增
- 哈希算法：取表中一列数据进行哈希运算，根据哈希结果存储至不同的节点
  - 数据分布较为均匀
  - 无法进行范围查询
  - 节点数量改变时需要重新计算哈希，并且重新分配数据
- 一致性哈希：将哈希值作为一个环，节点分布在环上，根据计算出的哈希值取顺时针的第一个节点
  - 修改节点数量时，仅影响与新节点相邻的节点
  - 由于节点取顺时针第一个，所以当一个节点失效时，数据会全部转移至下一个节点，容易导致热点数据和过高荷载
    - 虚拟节点：从真实的物理节点中产生若干个逻辑上的复制节点分布至环上，当有节点出现故障时可以避免全部流向一个节点

## 复制

将同一份数据备份至多个节点中，可以提高可用性、吞吐量，但也引入了数据同步的问题

## 复制算法

- 单主复制（主从同步）：只有一台主节点负责写操作，其他从节点负责同步主节点数据与提供读操作，主从节点间的同步分为三种：
  - 同步：主节点完成写操作后会等待所有从节点完成该数据同步，之后才返回写入成功的响应
    - 可以确保写入的数据不会丢失
    - 但在有从节点存在阻塞时，写效率较低
  - 异步：主节点不必等待从节点同步完成
    - 可能丢失数据
    - 写效率较高
  - 部分同步：主节点等待至少若干个从节点同步完成
  - 单主复制简单、易用，由于所有写操作都在主节点中，所以可以确保写操作的顺序性，且便于进行事务操作
  - 单主复制适用于读多写少的场景
  - 由于只有一个主节点，故当该节点故障时，如何重新选举主节点，确保数据的一致性，避免脑裂问题
- 多主复制：具有多个主节点，提高了写效率，同时可以避免主节点的单点故障，但主节点之间需要进行数据同步，同时由于网络延迟，各个主节点之间的执行顺序可能不同，导致出现数据冲突
  - 冲突避免：通过将用户的请求与特定的节点绑定（哈希），避免同一份数据在多个节点修改
  - 冲突处理：没有一种模型能够覆盖所有冲突情况，故大多数情况下多主复制带来的复杂性要高于便利性
    - 客户端处理：将冲突数据返回给客户端，由用户决定正确的数据（购物车）
    - 最后写入获胜（LWW）：将写入操作打上时间戳/ID，发生冲突时取最新的一个操作，但由于各个节点之间的机器时间可能不同，故该方法也存在误差
    - 因果律：判断写入操作之间的因果关系（happens-before）来决定合适的写入操作，但也存在没有因果关系的操作
- 无主复制：节点不再区分主从，写操作会向多个（甚至全部）节点发送，需要指定数量的节点响应成功后才视为写入完成，而读操作也会向多个节点请求
  - 不存在主节点也就不存在选举问题，但节点之间的数据一致性更加复杂
    - 读恢复：客户端处理的一种，由于读操作也会发往多个节点，故获取的多个结果中可能存在差异，此时由客户决定保留哪个并更新节点，但对于长期没有被读到的数据则可能丢失
    - 反熵：节点之间利用哈希树来快速比较数据的差异部分并修复，反熵过程不保证写操作顺序，只保证操作结果的一致
  - Quorum 算法：用于测算读写操作应该得到多少节点的响应才算成功的一致性算法
    - 对于 N 个节点，成功写入 W 个节点，读取 R 个节点，需要保证 W+R>N 且 W>N/2，由此保证每次读取数据都至少有一个节点是成功写入的，并且两个不同的写操作不会同时作用于一份数据

## CAP 理论

CAP 理论表明了无法构建完美的分布式模型，在进行架构设计时需要从三个方面进行取舍：

- 一致性：用户从所有节点读到的数据都是一致的
- 可用性：节点在没有故障时可以正常响应请求
- 分区容错性：在发生网络分区时系统能够正常工作

系统需要在发生网络分区时可以正常运作，故设计时一般选择 CP/AP

但是因为网络分区并非频繁发生，所以不必总是在一致性与可用性之间取舍，只需要在发生网络分区时进行判断，且 CAP 忽略了节点之间的网络延迟，当延迟较高时，放弃处理请求 --> 选择可用性，阻塞等待 --> 选择一致性， 例如在单主复制的场景，可以选择所有从节点都同步完成后再响应(CP)，也可以选择异步地在主从之间进行同步(AP)

## PACELC 理论

发生网络分区(P)时，考虑可用性(A)和一致性(C)之间的取舍，否则(E)考虑延迟(L)和一致性(C)之间的取舍

## 一致性模型

一致性：在并发编程中，系统与开发者之间的一种约定，当满足该约定时，读写操作的结果都是可预测的，可预测保证了系统的逻辑正确性

### 线性一致性

线性一致性是一种强一致性模型，在保证操作原子性和全局时序的情况下，令客户端将系统看作只有一个节点

将所有操作按时间线顺序排序，其中没有重叠的部分不可重新排序，而有重叠的部分(并发)可以任意重排序，当存在一种排序使得所有操作都合法(读操作能够正确读取到最近一次写操作结果)时可以视为符合线性一致性

### 顺序一致性

顺序一致性稍弱于线性一致性，它关注局部的有序，只要求每个客户端自身的执行顺序不可重排序，但多个客户端之间可以任意排序，故减少了维护全局时钟带来的开销

### 因果一致性

因果一致性弱于顺序一致性，它只要求含有因果关系的操作顺序不可变，没有因果关系的操作可以重排序

### 最终一致性

最终一致性是最弱的一致性模型，它不要求读操作必须返回最新的写操作结果，线程的操作也可以任意排序，只需要保证经过一段时间后，系统内的各个节点数据可以达到一致

## 面向客户端的一致性

面向客户端的一致性模型专注于单个客户端的数据一致性，即单个客户端在多个副本上读写时不会出现数据不一致的问题

- 单调读：客户端读到数据 v1 后，之后读取到的数据不会旧于 v1
- 单调写：客户端在所有副本的写操作顺序一致
- 读你所写：客户端写入 v1 后，之后读的操作都不会旧于 v1
- PRAM：客户端在所有副本的操作顺序一致，但多个客户端之间的操作可以乱序
- 读后写：对于数据 x，若在写操作 w1 后读取到数据 v1，则之后的写操作 w2 必须基于 v1 或更新的数据，确保操作之间的因果关系

## 隔离级别

隔离级别定义了在系统中各个并发事务之间操作的可见性

隔离级别主要关注于各个并发事务之间的正确执行，而数据一致性则是关注于多个客户端之间关于已提交事务的数据之间的正确执行

### 异常

事务之间的隔离主要是为了避免并发事务之间由于可见性带来的异常

- 脏读：在事务 A 中读到了事务 B 【未提交的数据】
- 脏写：在事务 A 中进行的写操作覆盖了事务 B 中的【未提交数据】
- 幻读：事务 A 在读取一个范围内的数据时，由于事务 B 提交的新增，导致在第二次读取时出现第一次中没有的数据
- 不可重读：事务 A 中对同一份数据的两次读取会因为事务 B 对该数据的修改而产生差异
- 更新丢失：事务 A 与 事务 B 同时更新一份数据，后提交的数据会覆盖【先提交的数据】，导致其中一份更新丢失
- 读偏斜：偏斜指不符合数据一致性，如 X，Y 存在一致性约束 X + Y = 100， 事务 A 在读取数据 X = 50 时，事务 B 将其修改为 X = 30，Y = 70，此时事务 A 读取到 Y = 70，破坏了数据一致性
- 写偏斜：事务 A 与事务 B 在读取后同时修改一部分数据，但两个修改的部分结合起来时会破坏数据一致性，如 X + Y < 100 且 X = 10，Y = 20，事务 A 将 X = 70，Y = 20，而事务 B 将 X = 10，Y = 80，虽然两者都认为没有破坏一致性，但其结果为 X + Y = 70 + 80 > 100

隔离级别：

- 串行化：严格对读写操作加锁，将并发的操作变成串行
- 可重读：通过锁/MVCC保证一次事务中的数据可以重复读取到同一个值
- 快照：MVCC
- 读已提交：只能读取其他事务已经提交的数据
- 读未提交：可以读到其他事务未提交的数据

## 分布式共识

共识即是分布式系统中所有的节点都同意某个值的最终值

- 最终性：所有节点最终都能够确定一个值
- 协定性：最终确定的值被所有节点认可
- 正确性：最终确定的值是所有节点提出的值中的一个，不是凭空生成的

达成共识的意义：

- 互斥锁：解决多个节点之间的操作执行顺序，实现分布式锁
- 选举：在单主复制中，当主节点故障时，需要多数节点达成共识来选举新的主节点，避免脑裂
- 原子操作：需要所有节点达成共识来实现事务的原子性

### FLP 不可能理论

FLP 不可能理论指出由于网络延迟的存在，一个完全异步的分布式系统中只要有一个节点出现故障就无法达成共识，即无法同时满足安全性，活性，容错性

- 安全性：所有节点都达成共识
- 活性：节点在一定时间内会认同一个最终值
- 容错性：系统在部分节点出现故障后仍能正常运行

虽然无法在完全异步的系统中达成共识，但可以通过引入部分同步等方法绕过 FLP 不可能定理：

- 故障屏蔽：将发生故障的节点视为正常，一直等待其响应，同时故障节点可以通过持久化数据进行重启和恢复
- 故障检测器：节点之间可以通过故障检测器感知到故障节点并将其从系统中驱逐
  - 完美故障检测器：
    - 所有故障节点会被所有正常节点检测
    - 所有正常节点都不会被怀疑
  - 最终弱故障检测器：
    - 所有故障节点最终都会被部分正常节点检测
    - 所有正常节点在一段时间后都不会被怀疑
- 随机性算法：通过引入随机性算法，破坏 FLP 定理中的【无法指定确定性算法】部分，系统根据以高概率保证达成共识，而非严格确定性

### Paxos 算法

Paxos 共识算法用于在多个节点中决议出一个最终值，它把节点分为四种角色：

- 客户端：向分布式系统发起请求
- 提议者：接收客户端请求，向投票者提出提议
- 投票者：多个投票者对提议进行投票，若半数投票者同意，则提议通过
- 学习者：学习者只读取提议值而不参与投票，当投票通过时会执行提议的操作

以无主复制为例，投票者可能会收到多个提议，每个节点选择接受的提议都可能不同：

- 节点接受第一个：如果所有节点都只取接收的第一个提议，则可能出现系统中没有过半数提议的情况，破坏了系统的活性(最终会得出一个确定值)
- 节点接受所有提议：如果节点接受收到的所有提议，则可能出现系统中存在多个过半数提议的情况，破坏了系统的安全性(得出同一个值)
- 二阶段协议：当提议 A 被系统批准后，参与提议 A 的节点此后不会再接受其他提议，由此保证系统只会批准一个提议。使用这种方式需要知道请求的顺序，在分布式系统中，通过组合递增的(请求 id，服务器 id)组合来标识请求的顺序
  - phase 1a：提议者收到客户端请求，生成新的提议编号并向多数的投票者广播
  - phase 1b：每个投票者收到提议编号后，比较其与自身持有的编号，若收到的编号更大，则记录该编号且承诺不再接受小于此编号的提议，若投票者本身已经持有提议值，则还需要将其一起返回，若收到的编号更小，则不予理会或返回拒绝
  - phase 2a：提议者收到来自多数投票者的通过响应，则向另一个多数节点广播提议编号与提议值，其中如果有来自 phase 1 的提议值，则直接使用，否则可以自己指定一个
  - phase 2b：投票者接收到提议值后，会先检查提议编号是否合法，再更新提议编号与提议值

活锁：当存在提议者 A 与 B，A 在发送 phase 1a 后还没发送 phase 2a 时，B 发送了编号值更大的 phase 1a，导致 A 的 phase 2a 中设置的共识值失效(选择编号更大的)，而在 B 发送 phase 2a 时 A 又发送 phase 1a，如此循环导致双方都无法成功设置值。可以通过设置超时来解决，即当提议者 A 在一段时间内无法获取到 phase 2b 的成功响应后，会进入休眠，让出机会来减小互相抢占的可能性