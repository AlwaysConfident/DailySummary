## 分布式计算谬误

1. 网络延迟问题
   1. 消息丢失
   2. 超时导致重传和误判不在线
   3. 乱序
2. 带宽
3. 网络安全
4. 拓扑结构改变
5. 单一管理员
6. 传输成本
7. 网络是同构的
8. 部分失效
9. 时钟问题
   1. 每台机器的时钟不同
   2. 网络传输存在时延

## 两将军问题

两个将军需要同时进攻一处堡垒，但由于派出的信使可能被俘，所以都无法确信对方是否收到消息，导致即使重复发出确认的消息，仍然无法保证消息可靠

该问题表明节点之间只能通过消息传递来确认彼此的状态

工程解：TCP 的三次握手

## 拜占庭将军问题

两将军问题的延申，多个将军协商进攻/撤退，但可能存在叛徒故意散布假消息(发送矛盾的消息)，该问题的主要目的是令忠诚的将领在同一个计划达成共识

## 网络链路模型

网络设备出现故障，但节点仍正常工作，导致节点之间无法通信，形成网络分区

链路：

- 可靠链路：不会丢失，不会凭空生成消息，可能乱序
- 公平损失链路：可能丢失，可以通过重发升级为可靠链路
- 任意链路：可能丢失，也可能被攻击者篡改、伪造数据，通过 TLS 等手段升级为公平损失链路

## 节点故障模型

节点可能在发送/接收消息时出现故障，导致消息丢失

节点故障类型：

- 崩溃-停止：节点发生硬件上的故障导致崩溃，一般来说进程失败后就永久退出运行状态，不再加入系统
- 崩溃-恢复：节点故障后可以通过重启等手段恢复并重新加入系统，通常需要日志、检查点等持久化存储进行恢复
- 拜占庭问题：节点故障后可能会令算法偏移甚至故意破坏算法

## 时分模型

根据消息的响应时间分为同步/异步模型

- 同步：消息在一段可预知的时间内响应，简单但不可靠，因为节点和网络可能出现故障
- 异步：无法预知消息何时响应，基于异步的算法更加健壮，且适用于同步场景，但存在 FLP 不可能问题
- 部分同步

## 消息传递语义

由于网络/节点可能存在故障，导致消息丢失，故需要进行重发，但重发的多个消息可能被执行多次，虽然可以通过幂等操作令其只生效一次，但需要一直等待确认请求来保证每个操作都是幂等的，开销较大

通过消息的唯一标识来避免多次执行：

- At Most Once：消息严格传递一次，即使丢失也不重发
- At Least Once：消息至少发送一次，丢失后会重发
- Exactly Once：消息精确发送一次，不会丢失，也不会重发，不现实，通过忽略重发来达到该效果

# 分布式数据

随着数据量的激增，单机下的数据库无法存储并提供满足要求的性能，故需要将数据库进行分区再部署至多台机器

## 分区

分片即将原数据库表进行分割，根据分割方向不同有：

- 水平分区：保持表结构，将一张表的数据分成多张表
- 垂直分区：按表的列进行分割，由于表的列有限，故分割的子表也有限

垂直/水平分区在查询数据时需要联接多个节点中的数据，考虑到节点间通信会十分低效

## 水平分区算法

- 范围算法：取表中的一列作为索引，如年份，进行分割，将对应范围内的数据都存储到一个节点中
  - 简单易用
  - 可以/仅能对索引列进行范围查找
  - 数据可能分布不均，导致出现热点数据，如某一年的数据激增
- 哈希算法：取表中一列数据进行哈希运算，根据哈希结果存储至不同的节点
  - 数据分布较为均匀
  - 无法进行范围查询
  - 节点数量改变时需要重新计算哈希，并且重新分配数据
- 一致性哈希：将哈希值作为一个环，节点分布在环上，根据计算出的哈希值取顺时针的第一个节点
  - 修改节点数量时，仅影响与新节点相邻的节点
  - 由于节点取顺时针第一个，所以当一个节点失效时，数据会全部转移至下一个节点，容易导致热点数据和过高荷载
    - 虚拟节点：从真实的物理节点中产生若干个逻辑上的复制节点分布至环上，当有节点出现故障时可以避免全部流向一个节点

## 复制

将同一份数据备份至多个节点中，可以提高可用性、吞吐量，但也引入了数据同步的问题

## 复制算法

- 单主复制（主从同步）：只有一台主节点负责写操作，其他从节点负责同步主节点数据与提供读操作，主从节点间的同步分为三种：
  - 同步：主节点完成写操作后会等待所有从节点完成该数据同步，之后才返回写入成功的响应
    - 可以确保写入的数据不会丢失
    - 但在有从节点存在阻塞时，写效率较低
  - 异步：主节点不必等待从节点同步完成
    - 可能丢失数据
    - 写效率较高
  - 部分同步：主节点等待至少若干个从节点同步完成
  - 单主复制简单、易用，由于所有写操作都在主节点中，所以可以确保写操作的顺序性，且便于进行事务操作
  - 单主复制适用于读多写少的场景
  - 由于只有一个主节点，故当该节点故障时，如何重新选举主节点，确保数据的一致性，避免脑裂问题
- 多主复制：具有多个主节点，提高了写效率，同时可以避免主节点的单点故障，但主节点之间需要进行数据同步，同时由于网络延迟，各个主节点之间的执行顺序可能不同，导致出现数据冲突
  - 冲突避免：通过将用户的请求与特定的节点绑定（哈希），避免同一份数据在多个节点修改
  - 冲突处理：没有一种模型能够覆盖所有冲突情况，故大多数情况下多主复制带来的复杂性要高于便利性
    - 客户端处理：将冲突数据返回给客户端，由用户决定正确的数据（购物车）
    - 最后写入获胜（LWW）：将写入操作打上时间戳/ID，发生冲突时取最新的一个操作，但由于各个节点之间的机器时间可能不同，故该方法也存在误差
    - 因果律：判断写入操作之间的因果关系（happens-before）来决定合适的写入操作，但也存在没有因果关系的操作
- 无主复制：节点不再区分主从，写操作会向多个（甚至全部）节点发送，需要指定数量的节点响应成功后才视为写入完成，而读操作也会向多个节点请求
  - 不存在主节点也就不存在选举问题，但节点之间的数据一致性更加复杂
    - 读恢复：客户端处理的一种，由于读操作也会发往多个节点，故获取的多个结果中可能存在差异，此时由客户决定保留哪个并更新节点，但对于长期没有被读到的数据则可能丢失
    - 反熵：节点之间利用哈希树来快速比较数据的差异部分并修复，反熵过程不保证写操作顺序，只保证操作结果的一致
  - Quorum 算法：用于测算读写操作应该得到多少节点的响应才算成功的一致性算法
    - 对于 N 个节点，成功写入 W 个节点，读取 R 个节点，需要保证 W+R>N 且 W>N/2，由此保证每次读取数据都至少有一个节点是成功写入的，并且两个不同的写操作不会同时作用于一份数据