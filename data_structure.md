# 数据结构

## 布隆过滤器

用于解决海量数据的存在性问题，对于海量数据中判断某个数据是否存在且容忍轻微误差(缓冲穿透，海量数据去重)

布隆过滤器是一种用于检索元素是否在给定大集合中的高效且占用空间小的数据结构，但也存在误差与难于删除的问题，且数据越多，误差率越高

### 原理

布隆过滤器由一个很长的二进制向量(位数组)和一系列随机映射函数实现

加入元素：

1. 使用哈希函数对元素值进行计算得到哈希值
2. 将哈希值在位数组对应的下标的值置为 1

判断元素是否存在：

1. 求给定元素的哈希值
2. 判断哈希值在数组中的每个元素是否都为 1，若存在不为 1 的值则说明该元素不在布隆过滤器中

![](https://img-blog.csdnimg.cn/img_convert/9ebde5c11ad69447314c216acf188fc8.png)

不同元素的哈希值可能相同，此时可以通过增加位数组大小或调整哈希函数来调整

布隆过滤器只能判断某个元素一定不存在或可能存在

## 红黑树

一种自平衡二叉搜索树，保证了最坏情况下在 O(logN) 复杂度内完成查找、插入、删除，性能表现稳定

二叉搜索树的形状取决于节点插入的顺序，若节点按升/降序的方式插入，那么二叉搜索树会退化为链表

### 特点

- 每个节点非黑即红，黑色决定平衡，红色不决定平衡
- 根节点必为黑色
- 每个叶节点都是黑色的空节点(Null)，红黑树都会有一个空的叶节点
- 红节点的子节点必为黑(反之不一定)，即不会有连续的红色节点，一个节点最多临时有 3 个节点，中间是黑色，左右是红色
- 从根节点到叶节点的每条路径，必须包含通过数目的黑节点，即黑高度相同

这些特点保证红黑树的平衡，让红黑树的高度不会超过 2log(n+1)，到达叶节点的最长路径不会超过最短路径的 2 倍

### 实现

```java
public class Node<T> {
    
    public T value;
    public Node<T> parent;
    public Node<T> left;
    public Node<T> right;
    public boolean isRed;
    
}
```

#### 左/右倾染色

1. 染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点
2. 再把父节点染黑，叔叔节点染黑，爷爷节点染红(在平衡树高操作后把根节点染黑)

#### 左旋调衡

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/6/1602b60230926ead~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

1. 父节点 X 被右子节点 Y 取代
2. X 成为 Y 的左子节点
3. 原右子节点(现父节点)的左子节点 b 成为 X 的右节点

#### 右旋调衡

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/6/1602b6024ce2b0c4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

1. 父节点 X 被左子节点 Y 取代
2. X 成为 Y 的右子节点
3. Y 的右子节点 c 成为 X 的左子节点

#### 插入

- 叔叔节点为:red_circle:

  - 变色，将叔叔节点与父节点变为黑色，爷爷节点变为红色(根节点则再变为黑色)，若变色后新节点的爷爷节点的父节点不为黑，则以爷爷节点为起点继续变色

    ![](https://pic1.zhimg.com/80/v2-85d7be8e54ae9f904d86bf5f5ee3b4bc_720w.webp)

- 叔叔节点为空，且爷爷节点、父节点、新节点处于一条斜线

  - 旋转：插入左节点 --> 右旋；插入右节点 --> 左旋

    ![](https://pic3.zhimg.com/80/v2-cd2171937e0ed68bca55214357e6669e_720w.webp)

- 叔叔节点为空，且爷爷节点、父节点、新节点不处于一条斜线

  - 旋转：先将插入节点右/左旋至一条斜线的情况，再进行左/右旋

    ![](https://pic4.zhimg.com/80/v2-8594087429e54acbbc2aa6ae9da8cc5f_720w.webp)

#### 删除

在遇到被删除节点是红色或到达 root 节点时无需修复

当黑色节点被删除后会让树不符合 RBTree 的定义(黑高度相同)，需要从兄弟节点上借调黑节点，若兄弟节点没有黑节点，就只能往上追溯，将每一级的黑节点数减去一个，使得整个树符合定义

只对删除黑节点做修复：

- 删除节点的(右)兄弟节点为黑色，且有一个右节点(必为红色)

  - 将父节点的颜色赋给兄弟节点

  - 将父节点和(兄弟节点的右子节点)都置为黑色

  - 对父节点进行左旋

    ![](https://pic4.zhimg.com/80/v2-94335b8ae50c956aaeca618f6bc90713_720w.webp)

    ![](https://pic3.zhimg.com/80/v2-f30cb523a94240fe4dbe2832832c0492_720w.webp)

- 删除节点的(右)兄弟节点为黑色:black_circle:，且兄弟节点有一个左子节点

  - 将左子节点设为黑色

  - 将兄弟节点设为红色

  - 对兄弟节点右旋

  - 转换为(右)兄弟节点存在右子节点的情况

    ![](https://pic3.zhimg.com/80/v2-7d1cf28f3b0b67b6d5025d3f9be898ba_720w.webp)

    ![](https://pic3.zhimg.com/80/v2-9b4774e7f02943891b398b16e961dd76_720w.webp)

- (右)兄弟节点为黑色，且兄弟节点有两个子节点

  - 将父节点的颜色赋给兄弟节点

  - 将兄弟节点的右子节点设为黑色

  - 将父节点设为黑色

  - 将父节点左旋

    ![](https://pic4.zhimg.com/80/v2-183791331dfea42bf8fab6f4da150d0b_720w.webp)

    ![](https://pic2.zhimg.com/80/v2-0a192f04534d6d0dff7019aa917e6111_720w.webp)

- (右)兄弟节点为黑色，且兄弟节点没有子节点

  - 将兄弟节点设为红色

  - 将父节点设置为当前节点递归，直到根节点，或遇到红色节点(修改了父节点的颜色，需要递归保证整树的合法性)

    ![](https://pic2.zhimg.com/80/v2-72a66803d5eae93432b5763f75cd7d59_720w.webp)

    ![](https://pic1.zhimg.com/80/v2-e82d35477e9efcbbe18c387f05872224_720w.webp)

- (右)兄弟节点为红色

  - 将兄弟节点设为黑色

  - 将兄弟节点的左孩子设为红色

  - 将父节点左旋

    ![](https://pic4.zhimg.com/80/v2-938647e3d80affebe077082bc219b1d7_720w.webp)