# 数据库

- 元组：关系是一张表，表中的每行就是一个元组
- 码：唯一标识实体的属性，对应表中的列
- 候选码：关系中的某一属性/属性组的值能唯一标识一个元组，而其任何子集都不能再标识，则该属性组为候选码
  - 主键 → 学号
  - 候选码 → 姓名，班级(只有这两者也能唯一标识一个学生)
- 主键：从候选码中选出的一个，一个表中只能有一个且不能为空，不能重复
- 外键：一个关系中的属性是另一个关系中的主键，一个表中可以有多个外键，且可以为空，可以重复
  - 一般不适用外键：
    - 增加复杂性：每次 DELETE 和 UPDATE 都需要考虑外键约束；外键的关系是定死的，故需求变化时也需要对表做修改
    - 分库分表：分库分表下外键无法生效
  - 外键保证数据库的一致性和完整性，级联操作方便，减轻程序代码量，在不涉及分库分表且并发量不高的情况下可以使用
- 主属性：候选码中出现过的属性
- 非主属性：不在任何一个候选码中出现的属性

## 范式

- 1NF：属性不可再分
- 2NF：1NF 的基础上，消除了非主属性对于键的部分函数依赖(所以非主属性都依赖于主键)
- 3NF：2NF 的基础上，消除了非主属性对于键的传递函数依赖(所有非主属性都不依赖于其他非主属性)

范式有助于维护数据一致性和完整性，高级别的范式通常可以减少数据冗余，提高数据一致性，但也可能增加复杂性和查询性能的开销(联表查询)

### 1NF

属性不能再被分割，即这个字段只能是一个值，无法再分为多个其他的字段，1NF 是所有关系型数据库的基本要求

存在数据冗余过大、删除异常、插入异常、修改异常的问题

### 2NF

在 1NF 基础上，消除了非主属性对于键的部分函数依赖，2NF 在 1NF 的基础上增加了一个主键列，非主属性都依赖于主键

![第二范式](https://oss.javaguide.cn/github/javaguide/csdn/bd1d31be3779342427fc9e462bf7f05c.png)

- 函数依赖：在一张表中，可以由 X 确定 Y，即 X → Y，则 Y 函数依赖于 X
- 部分函数依赖：X → Y 且存在 X 的真子集 X0 → Y，则 Y 对X 部分函数依赖
  - 学生表 R(学号、身份证号、姓名)中，有 (学号、身份证号) → (姓名)、(学号) → (姓名)、(身份证号) → (姓名)，则姓名部分依赖于 (学号、身份证号)
- 完全函数依赖：某个非主属性数据项依赖于全部候选项，则为完全函数依赖
  - 学生表 R(学号、班级、姓名)中，有 (学号、班级) → (姓名)，即只有确定了学号和班级后才能唯一确定姓名，只知道学号或班级则无法确定姓名，故姓名完全函数依赖于 (学号、班级)
- 传递函数依赖：在 R(U) 中， X → Y，Y —/→ X，Y → Z，Z 不属于 Y，则 Z 对 X 传递函数依赖
  - 学生表 R(学号、姓名、系名、系主任) 中，学号 → 系名，系名 → 系主任，所以存在非主属性系名对学号的传递函数依赖

### 3NF

3NF 在 2NF 的基础上，消除了非主属性对键的传递函数依赖(任何非主属性不依赖于其他非主属性)，符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常

## 存储过程

存储过程可以看作一些 SQL 语句的集合，中间加入逻辑控制语句，在业务复杂时比较实用，可以方便调用。

存储过程一旦调试完成后就能稳定运行，且使用存储过程比单纯 SQL 语句执行要快，因为存储过程预编译过

但存储过程在高并发、分库分表、需求更新频繁的场景应用不多，因为存储过程难以调试和扩展(无法配合中间件使用)，且没有移植性(数据库的升级、迁移)，还会消耗数据库资源

## drop vs delete vs truncate

|            | drop                                                         | delete                                              | truncate                                                     |
| ---------- | ------------------------------------------------------------ | --------------------------------------------------- | ------------------------------------------------------------ |
| 用法       | 删除表                                                       | 删除某一行数据，若不带筛选条件，则同 truncate       | 删除表数据，主键 id 从 1 开始                                |
| 数据库语言 | DDL，操作立即生效，原数据不放入 rollback segment，不能回滚，操作不触发 trigger | DML，操作放入 rollback segment 中，事务提交后才生效 | DDL                                                          |
| 执行速度   | 直接释放表占用的空间，速度最快                               | 执行时会产生数据库的 binlog 日志，需要消耗时间      | 执行时不会产生 binlog，但需要把表的自增值重置和索引恢复到初始大小 |

## NoSQL 

Not Only SQL，非关系型数据库，主要针对键值、文档、图形类型数据存储。

NoSQL 天生支持分布式、数据冗余、数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案

NoSQL 适合需要灵活、可扩展、高性能和功能强大的数据库来提升用户体验的现代应用程序(移动、Web 和游戏应用程序)

- 灵活性：NoSQL 的架构灵活，便于迭代开发；NoSQL 的数据结构灵活，支持非关系型数据结构
- 可扩展性：NoSQL 天然支持分布式，可以通过增加分布式硬件集群来横向扩展，而不必使用更高性能的服务器纵向扩展
- 高性能：NoSQL 针对特定的数据模型和查询模式进行优化
- 功能强大：NoSQL 提供各种功能强大的 API 和数据类型

### SQL vs NoSQL

|              | SQL                                                          | NoSQL                                              |
| ------------ | ------------------------------------------------------------ | -------------------------------------------------- |
| 数据存储模型 | 结构化存储，具有固定行和列的表格                             | 非结构化存储：JSON、键值对、节点和边               |
| 重点         | 减少数据重复                                                 | 提升可扩展性，减少大规模数据的存储成本             |
| ACID         | 提供原子性、一致性、隔离性、持久性                           | 为了可扩展、高性能，通常不支持 ACID 事务           |
| 性能         | 取决于磁盘子系统，需要通过优化查询、索引和表结构获得最佳性能 | 性能由底层硬件集群大小、网络延迟及调用应用程序决定 |
| 扩展         | 垂直(使用性能更强的服务器扩展)，读写分离，分库分表           | 横向(增加服务器，基于分片机制)                     |
| 用途         | 普通企业级的项目的数据存储                                   | 用途广泛                                           |
| 查询语法     | SQL                                                          | 因数据库而异                                       |

### 存储类型

- 键值：每个项目都包含 key 和 value，极为灵活的数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制

- 文档：数据被存储在类似 JSON 的文档中，清晰直观，每个文档包含成对的字段和值

  ![](https://www.runoob.com/wp-content/uploads/2013/10/Figure-1-Mapping-Table-to-Collection-1.png)

- 图形：旨在轻松构建和运行与高度连接的数据集一起使用的应用程序，实体作为顶点，实体之间的关系则被作为边，图形数据库的典型使用包括社交网络、推荐引擎、欺诈检测、知识图形

- 宽列：适用于存储大量数据，数据按列存储，故可以压缩大量重复的数据

## MySQL

MySQL 是一种关系型数据库，主要用于持久化存储系统中一些数据

MySQL 开源免费且比较成熟，默认端口为 3306

### 优点

- 开源免费
- 成熟稳定，功能完善
- 文档丰富，易于学习使用
- 开箱即用，操作简单，维护成本低
- 兼容性好，支持常见的操作系统与开发语言
- 生态完善
- 事务支持优秀
- 支持分库分表、读写分离、高可用

### 字段类型

- 数值类型
- 字符串类型
- 日期时间类型

![MySQL 常见字段类型总结](https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png)

MySQL 中没有布尔值，一般使用 TINYINT(1) 存储 0 和 1 表示

#### 整数类型的 UNSIGNED

表示不允许负值的无符号整数，使用 UNSIGNED 属性能够将正整数的上限提高一倍(不需要存储负值)

可以用于从 0 开始递增的 ID 列，提高 ID 的上限范围

#### CHAR vs VARCHAR

- CHAR 为定长字符串，在存储时会在右边填充空格以达到指定长度，检索时去除空格，适用于长度较短或长度相差不大的字符串(手机号、身份证号)
- VARCHAR 为变长字符串，在存储时使用 1-2 个额外字节记录字符串长度，检索时不需要处理，适用于存储长度较长或长度相差大的字符串

CHAR(M) 与 VARCHAR(M) 都表示最多能保存 M 个字符数，所有字符类型(数字、字母、汉字)都只占用一个字符

#### VARCHAR(10) vs VARCHAR(100)

- 最大长度：10 vs 100；当 VARCHAR(10) 需要存储超过 10 个字符时，需要修改表结构
- 存储占用空间：都存储相同字符数的字符串时，占用的磁盘存储空间相同
- 内存占用：在内存中操作时，VARCHAR(100) 会占用 100 个字符的内存空间，无论其实际使用的大小

#### DECIMAL vs FLOAT/DOUBLE

- DECIMAL 是定点数，可以存储精确的小数(类比 BigDecimal)
- FLOAT/DOUBLE 为浮点数，只能存储近似的小数值

#### TEXT & BLOB

TEXT 类似于 CHAR 和 VARCHAR，但能存储更长的字符串(长文本数据，文章内容)

BLOB 存储二进制大对象，如图片、音视频

不推荐使用 TEXT 与 BLOB：

- 不能有默认值
- 只能在磁盘使用临时表
- 检索效率低
- 不能直接创建索引，需要指定前缀长度
- 可能消耗大量网络和 IO 带宽
- 可能导致表上的 DML 操作变慢

#### DATETIME vs TIMESTAMP

- 时区：DATETIME 没有时区信息，只保存当前会话设置的时区对应的时间；TIMESTAMP 与时区相关，存储的值会自动换算成服务器时区
- 存储空间：8 字节 vs 4 字节；TIMESTAMP 表示的时间范围更小(2038 年)
  - MySQL 5.6.4 前，DATETIME 与 TIMESTAMP 的存储空间是固定的
  - MySQL 5.6.4 后，两者的存储空间会根据毫秒精度不同而变化，DATETIME 为 5-8 字节，TIMESTAMP 为 4-7 字节
- 性能：TIMESTAMP 需要根据时区进行转换，所以从毫秒转换为 TIMESTAMP 时还要调用操作系统底层的系统函数保证系统时区的一致性，并且需要加锁操作

字符串存储时间：占用空间更大，且无法使用 API，效率更低(逐个字符比较)

数字时间戳：日期的排序、比较效率更高，跨系统更方便，但可读性较差

#### NULL vs ''

NULL != ''

- 含义：NULL 表示不确定的值，两个 NULL 也不一定相等；'' 表示空字符串
- 占用空间：NULL 占用空间；'' 长度为 0，不占用空间
- 函数运算：NULL 影响聚合函数结果，部分聚合函数会忽略 NULL 值(SUM、AVG、MIN、MAX)，COUNT(*) 时会计算 NULL 行
- 查询：NULL 值只能使用 IS NULL 或 IS NOT NULL 查询

### MySQL 架构

![](https://pic1.zhimg.com/80/v2-b29359b4bc5e849601c5df10a2a8e484_720w.webp)

- 连接器：身份认证与权限相关
- 查询缓存：执行查询语句时会先查询缓存(MySQL 8.0 后移除，因为不太实用)
- 分析器：对 SQL 语句进行词法、语法分析，了解 SQL 语句的目的与检查 SQL 语句的语法是否正确
- 优化器：MySQL 对 SQL 语句进行优化(索引)
- 执行器：先判断权限，之后执行 SQL 语句后从存储引擎返回数据
- 插件式存储引擎：负责数据的存储和读取，采用插件式架构，支持多种存储引擎

### 存储引擎

MySQL 支持多种存储引擎，5.5.5 之前默认使用 MyISAM，之后默认使用 InnoDB，且只有 InnoDB 为事务性存储引擎(支持事务)

存储引擎采用插件式架构，支持多种存储引擎，存储引擎是基于表而不是数据库

#### MyISAM vs InnoDB

- 行级锁：MyISAM 只有表级锁，即 MyISAM 一锁就是锁住整张表，影响并发性能；InnoDB 默认为行级锁
- 事务：MyISAM 不提供事务支持；InnoDB 提供了事务支持，实现了 SQL 标准定义的四个隔离级别，具有 commit 和 rollback 事务的能力，InnoDB 默认使用可重读隔离级别能够解决幻读问题(基于 MVCC 和 Next-Key Lock)
- 外键：MyISAM 不支持外键；InnoDB 支持外键
  - 一般在应用层面实现外键的功能，因为数据库中使用外键会增加数据库开销和复杂度，且外键不支持分库分表
- 数据库异常崩溃后的安全恢复：MyISAM 不支持；InnoDB 在异常崩溃后，数据库重新启动时会保证数据库恢复到崩溃前的状态(redo log)
- MVCC：MVCC 可以看作行级锁的升级，可以有效减少加锁操作，提高性能
- 索引：两者都使用 B+ 树作为索引的底层实现
  - MyISAM 中索引文件和数据文件是分离的
  - InnoDB 中数据文件本身就是索引文件，其表数据文件本身就是按 B+ Tree 组织的一个索引结构，树的叶节点 data 域保存完整的数据记录
- 性能：MyISAM 读写不能并发；InnoDB 在读写混合或只读模式下，读写能力随 CPU 核数线性增长

![常见的几种 MySQL 存储引擎对比](https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png)