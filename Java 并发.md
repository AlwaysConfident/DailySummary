# Java 并发

## 进程

进程是程序的一次执行过程(系统运行一次程序即是进程的创建、运行、消亡)，是**系统运行程序的基本单位**，因此进程是动态的

## 线程

线程是比进程更小的执行单位，一个进程在执行时可能生成多个线程，同类线程之间**共享进程的堆和方法区**的同时也拥有自己的**程序计数器、本地方法栈、虚拟机栈**，所以线程的产生与切换的开销比进程小得多

Java 程序天生就是多线程程序

## Java 线程 vs 操作系统线程

Java 2 前，Java 的线程由绿色线程(Green Thread) 实现，即 JVM **基于操作系统的用户线程**模拟多线程的运行，而不依赖与操作系统。但用户线程的使用有限制(无法直接使用操作系统提供的功能如异步 I/O，只能在一个内核线程上运行无法利用多核)

Java 2 后，Java 的线程改为原生线程(Native Thread)实现，即 JVM **直接使用操作系统原生的内核线程**，由操作系统内核进行线程的调度与管理

- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间(应用程序)，创建和切换的成本较低，但有限制
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间，能够利用多核，但创建与切换的成本高

Java 线程本质上是操作系统线程

## 线程 vs 进程 (JVM)

一个进程可以有多个线程，进程之间相互独立，同类线程共享进程的堆与方法区(Java 8 后为元空间)资源，每个线程又有自己私有的程序计数器、虚拟机栈、本地方法栈

进程的创建与切换的开销较大，线程的创建与切换的开销较小，但线程共享资源不利于资源的管理和保护

### 程序计数器

- 代码的流程控制：通过改变程序计数器来依次执行指令(Java 方法，执行 native 方法时为 undefined)
- 多线程下的还原：用于标识线程在字节码中走到哪一步，便于线程切换时还原

### 虚拟机栈与本地方法栈

线程在方法调用时会为当前状态(局部变量表，操作数栈，常量引用池等)创建栈帧并入栈，在调用完成后再出栈还原状态

虚拟机栈用于 Java 方法，而本地方法栈用于 native 方法，在 Hotspot JVM 中将两者合二为一

虚拟机栈与本地方法栈的线程私有**保证线程中的局部变量不会被其他线程访问**

### 堆与方法区

堆与方法区是所有线程共享的资源

- 几乎所有创建的对象都存储在堆中(JIT 标量替换后会创建在栈中)
- 方法区用于存储已加载的类信息、常量、静态变量、JIT 缓存等

## 创建线程

继承 Thread 类，实现 Runnable 接口，实现 Callable 接口都能创建线程，但严格来说都是需要通过 new Thrad().start() 来创建

Runnable，Callable 对象只是提供给线程执行的任务

## 线程的生命周期与状态

- NEW：线程刚被创建
- RUNNABLE：线程准备好执行所需的资源的运行状态
  - JVM 将线程的 READY 与 RUNNING 状态合并，因为如今 CPU 的时间分片很小，即每个线程只会在 CPU 执行很短的时间(10-20ms)，故线程在 READY 与 RUNNING 状态之间切换十分快，区分两种状态的意义不大
- BLOCKING：线程被阻塞，等待锁(会主动获取锁)，由于获取不到锁而被动进入阻塞状态
- WAITING：线程休眠，需要等待通知(唤醒)才会尝试获取锁，由 wait() 方法主动进入等待状态
- TIME_WAITING：线程定时，在指定时间后自动返回而不会一直等待(WAITING)
- TERMINATED：线程终止

![](https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXQFkYWhfJUhibHcHb4VoVp9Je8FwJvhEDcn1zwhktV7iaTjkozU2LoiaqO3XP5fDibWichGyJ5uwN3cqnQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 线程上下文切换

线程让出 CPU 资源：

- 线程进入 WAITING/TIME_WAITING 状态(wait()，sleep())
- CPU 调度线程
- 线程阻塞(请求 I/O)
- 线程完成或被终止

在前三种情况，线程保存在执行过程中的信息(程序计数器、栈)，即上下文后主动让出 CPU 资源，等待线程下次占用时还原现场，再加载下一个线程的上下文

由于保存/恢复信息有额外的开销，故频繁切换线程会降低效率

## 线程死锁

线程死锁即两个线程都因为等待对方持有的资源释放而无限期地处于阻塞状态

### 死锁产生的必要条件

- 互斥：资源只能被一个线程持有
- 请求与保持：线程不会主动放弃持有的部分资源
  - 破坏：线程只会一次性请求所有资源
- 不剥夺：线程持有的资源不会被其他线程剥夺，只能等待线程主动释放
  - 破坏：线程在阻塞时主动放弃持有的资源
- 循环等待：线程之间的等待关系构成环
  - 破坏：人为对资源的请求排序

### 避免死锁

通过算法为资源的分配进行评估，使其进入安全状态(存在一种分配顺序，使每个线程最终都能顺利完成)

## sleep() vs wait()

两者都会让线程进入 WAITING/TIME_WAITING 状态

- 锁：wait 会主动释放锁；sleep 不会释放锁
- 唤醒：wait 需要等待同一对象的 notify/notifyAll 唤醒，或使用 wait(time) 定时唤醒；sleep 会定时唤醒
- 用法：wait 用于线程间通信；sleep 用于暂停线程
- 从属：wait 从属于 Object 类的本地(native)方法；sleep 从属于 Thread 类的静态本地方法
  - wait() 让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁
    - 对象锁：每个对象 (Object) 都拥有对象锁(JVM 负责跟踪对象被加锁的次数)，若要释放当前线程占有的对象锁并进入 WAITING 状态，就需要操作对应对象(Object)而非当前的线程(Thread)
  - sleep() 只让当前线程暂停而不需要释放锁，故其操作对象只涉及线程

## 直接调用 Thread 类的 run 方法

调用 Thread 类的 run 方法会执行线程体，但不会新建线程(内部调用 Runnable 的 run 方法)，即线程体会运行在 main 线程中，即使由 new Thread 对象调用的 run 方法

需要通过 Thread 对象的 start 方法才能真正启动一个线程并使线程进入就绪状态后获取时间片运行

调用 start() 方法可以启动线程并使线程进入就绪状态，直接运行 run() 方法不会以多线程方式执行(main 线程中执行)

## Volatile

### 如何保证可见性

- 读操作：volatile 修饰的变量在读操作前会将工作内存的变量设为无效，再从共享内存中读取
- 写操作：volatile 修饰的变量的写操作会直接将结果写入主存，不保证线程安全性(n 个线程执行 cnt++ 操作的结果不一定是 cnt + n，因为线程只会在一开始的读操作保证当前的数据是最新的)

### 禁止指令重排序

volatile 修饰的变量进行读写操作时会通过插入内存屏障来禁止重排序

#### 单例模式

````java
public class Singleton {
    
    private volatile static Singleton instance;
    
    public static Singleton getInstance(){
        // 判断单例对象是否已创建
        if(instance == null){
            // 类对象加锁
            synchronized (Singleton.class) {
                // 加锁前已被其他线程创建
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    
}
````

volatile 修饰 instance：

- 由于 new Singleton() 分为三步执行：
  1. 在堆中分配内存空间
  2. 初始化对象
  3. 将分配的内存空间地址赋值给栈中变量
- 其中 2，3 步可能发生重排序，即先将内存空间地址赋值给栈
- 若此时为多线程环境，则可能线程 A 执行 1，3 后，instance 为非空但未初始化，线程 B 此时判断 instance 非空并直接返回未初始化的 instance

### 保证原子性

volatile 可以保证单个变量的可见性，不能保证对变量操作的原子性

````java
public volatile static int inc = 0;

public void increase() {
    // 非原子性操作
    // 1. 读取 inc
    // 2. 修改 inc
    // 3. 写回 inc
    inc++;
}

public void exc() {
    ExecutorService threadPool = Executors.newFixedThreadPool(5);
    for(int i = 0; i < 5; i++) {
        threadPool.execute(() -> {
            for(int j = 0; j < 500; j++){
                increase();
            }
        })
    }
}
````

此时 inc 的值不一定为 2500，因为 volatile 只会保证线程在进行读操作时获取到的是最新的数据，并不能保证读之后其他线程的修改是可见的，即：

1. 线程 A 读取 inc，此时的 inc 是最新的
2. 线程 B 写回 inc，此时的 inc 为 inc + 1，但线程 A 仍使用原本的 inc
3. 线程 A 将 inc + 1 写回主存，但正确结果应为 inc + 2

可以使用 synchronized、ReentrantLock、AtomicInteger 保证原子性

## 悲观锁

悲观锁即每次读都假设数据会被修改，故**每次操作都会上锁**，从而阻塞其他线程的操作，即严格要求共享资源只被一个线程使用(读/写)

Java 中的 synchronized、ReentrantLock 等独占锁就是悲观锁的实现

```java
public void performSynchronizedTask() {
    synchronized(this) {
        // 需要同步的操作
    }
}

private Lock lock = new ReentrantLock();
lock.lock();
try {
    // 需要同步的操作
} finally {
    lock.unlock();
}
```

高并发场景下，激烈的锁竞争会造成大量阻塞，从而引起大量的线程上下文切换，增加性能开销

悲观锁也存在死锁问题

故悲观锁适用于写多读少的场景，因为悲观锁的开销是固定的(所有操作都加锁)，可以避免频繁失败与重试带来的影响

## 乐观锁

乐观锁假设读操作时一定不会发生修改，即**不加读锁，只在写操作执行时验证数据是否被修改**(版本号，CAS 算法等)

Java 中的原子变量类(AtomicInteger、LongAddr)就是使用了乐观锁(CAS)的一种实现

在高并发场景，不加锁、不阻塞的乐观锁的性能远高于悲观锁，但当冲突频繁发生时(写操作居多)会频繁失败与重试，也会对性能产生影响

故乐观锁适用于读多写少的场景，因为不需要为读操作加锁与阻塞，只有在写操作时可能失败与重试

### 乐观锁实现

#### 版本号

在数据库表中加入 version 字段，表示数据修改的次数(每次修改加一)，当更新数据时只有与当前数据库中的版本一致才允许更新，否则重试更新操作

#### CAS 算法

Compare And Swap，即使用预期值(E)与当前值(V)比较，两值相等时才会更新需要写入的新值(N)

CAS 是依赖于 CPU 原子指令的原子操作，由 C++ 内联汇编的形式实现，通过 JNI 调用，故可以保证比较的原子性，且 CAS 算法与操作系统及 CPU 相关

### 问题

#### ABA

若用于比较的当前值(V)在比较期间发生 A->B->A 的变化，则在乐观锁看来此变量未被改变过

解决思路：为 V 添加版本号/时间戳，确保 V 的唯一性

#### 循环时间长开销大

CAS 使用自旋操作进行重试，即一直重试到成功，故长时间不成功会带来巨大开销

解决思路：使用 CPU 提供的 pause 指令延迟重试，并且避免在退出循环时因内存顺序冲而引起 CPU 流水线被清空

#### 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，操作涉及多个共享变量时无效

从 Java 5 开始使用 AtomicReference 类保证引用对象间的原子性，可以把多个变量放入一个对象中进行 CAS 操作，即可以利用锁/AtomicReference 类把多个共享变量合并成一个共享变量操作

## Synchronized

synchronized 关键字用于保证多线程访问共享变量时的同步性，可以保证同一时刻只有一个线程执行代码块/方法

- Java 6 前：synchronized 是重量级锁，底层基于操作系统的 Mutext Lock 互斥锁实现，Java 的线程挂载于操作系统的线程，每次线程的阻塞/唤醒操作都需要操作系统 用户态->内核态->用户态 的转换
- Java 6 后，synchronized 进行了大量优化，引入了自旋锁，轻量级锁，锁销除，锁粗化，偏向锁等技术来减少开销

偏向锁的引入增加了 JVM 的复杂度，且性能提升不大，故在 Java 15 中默认关闭，在 Java 18 中废弃

### 使用

- 实例方法：给对象实例加锁
- 静态方法：给当前类加锁
  - 实例方法与静态方法不互斥：线程 A 调用实例对象的非静态 synchronized 方法，获取实例对象的锁；线程 B 调用实例对象的静态 synchronized 方法，获取当前类的锁
- 代码块
  - synchronized(object)：进入代码块前获取给定对象的锁
  - synchronized(class)：进入代码块前获取给定类的锁

synchronized 不能修饰构造函数，因为构造函数本身是线程安全的，即每个线程 new 的对象是独立的，并不会产生冲突，但构造函数的参数可能是共享的，故构造函数内的代码块可以被 synchronized 修饰

### 底层实现